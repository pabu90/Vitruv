import "http://www.eclipse.org/uml2/2.1.0/UML" as uml

//444		Categories
//124		IGN_{NESTED|ILLEGAL|SEQUENCE|COMPLEX|TEXTUAL} (illegal = cast/allinstances/closure) (sequence = first/last/index)
//80		SIZE_{ONE|EMPTY|COMP}
//70		INV_{OK|RE}
//170		ATTR

// INV_{FORALL|EXISTS|SELECT_FORALL|SELECT_EXISTS|MAP_EXISTS|MAP_FORALL}*
// SIZE
// ATTR
// IGN_{ILLEGAL|COMPLEX|TEXTUAL}
		

      
// --- --- --- class --- Activity */

// --- invariant maximum_one_parameter_node 
// --- category INV_FORALL
// OCL --- A Parameter with direction other than inout must have exactly one ActivityParameterNode in an Activity.
// INV --- ownedParameter->forAll(p | 
// INV ---    p.direction <> ParameterDirectionKind::inout implies node->select(
// INV ---        oclIsKindOf(ActivityParameterNode) and oclAsType(ActivityParameterNode).parameter = p)->size()= 1)
invariant maximum_one_parameter_node (uml.Parameter p)
context uml.Activity
check _self.ownedParameters.forAll[org.eclipse.uml2.uml.Parameter p|
	(p.direction != org.eclipse.uml2.uml.ParameterDirectionKind.INOUT).implies(_self.nodes.select[n|
		n.oclIsKindOf(org.eclipse.uml2.uml.ActivityParameterNode) && n.oclAsType(org.eclipse.uml2.uml.ActivityParameterNode).parameter == p
	].size == 1)
]
      
      
// --- invariant maximum_two_parameter_nodes 
// --- category IGN_COMPLEX
// OCL --- A Parameter with direction inout must have exactly two ActivityParameterNodes in an Activity, at most one with incoming ActivityEdges and at most one with outgoing ActivityEdges.
// INV --- ownedParameter->forAll(p | 
// INV --- p.direction = ParameterDirectionKind::inout implies
// INV --- let associatedNodes : Set(ActivityNode) = node->select(
// INV ---        oclIsKindOf(ActivityParameterNode) and oclAsType(ActivityParameterNode).parameter = p) in 
// INV ---   associatedNodes->size()=2 and
// INV ---   associatedNodes->select(incoming->notEmpty())->size()<=1 and
// INV ---   associatedNodes->select(outgoing->notEmpty())->size()<=1
// INV --- )
invariant maximum_two_parameter_node
context uml.Activity
check _self.ownedParameters.forAll[p|
	(p.direction != org.eclipse.uml2.uml.ParameterDirectionKind.INOUT).implies(
		{
			val associatedNodes = _self.nodes.filter[
				(it as java.lang.reflect.AccessibleObject).accessible
			]
			associatedNodes.size == 2 &&
			associatedNodes.select[!it.incomings.empty].size <= 1
		})
]

// --- --- --- class --- Behavior */

// --- invariant most_one_behavior
// --- category SIZE
// OCL --- There may be at most one Behavior for a given pairing of BehavioredClassifier (as owner of the Behavior) and BehavioralFeature (as specification of the Behavior).
// INV --- specification <> null implies _''.ownedBehavior->select(specification=self.specification)->size() = 1
       

// --- invariant parameters_match 
// --- category SIZE
// OCL --- If a Behavior has a specification BehavioralFeature, then it must have the same number of ownedParameters as its specification. The Behavior Parameters must also &quot;match&quot; the BehavioralParameter Parameters, but the exact requirements for this matching are not formalized.
// INV --- specification <> null implies ownedParameter->size() = specification.ownedParameter->size()
      

// --- invariant feature_of_context_classifier
// --- category INV_EXISTS
// OCL --- The specification BehavioralFeature must be a feature (possibly inherited) of the  BehavioredClassifier of the Behavior.
// INV --- _''.feature->includes(specification)
invariant feature_of_context_classifier (uml.Feature f)
context uml.Behavior
check _self.features.exists[org.eclipse.uml2.uml.Feature f|f == _self.specification]
      
// --- --- --- class --- Class */

// --- invariant passive_class
// --- category ATTR
// OCL --- Only an active Class may own Receptions and have a classifierBehavior.
// INV --- not isActive implies (ownedReception->isEmpty() and classifierBehavior = null)
      
// --- --- --- class --- BehavioredClassifier

// --- invariant class_behavior
// --- category SIZE
// OCL --- If a behavior is classifier behavior, it does not have a specification.
// INV --- classifierBehavior->notEmpty() implies classifierBehavior.specification->isEmpty()
      
// --- --- --- class --- Classifier */

// --- invariant specialize_type
// --- category INV_FORALL
// OCL --- A Classifier may only specialize Classifiers of a valid type.
// INV --- parents()->forAll(c | self.maySpecializeType(c))
invariant specialize_type (uml.Classifier c)
context uml.Class
check _self.parents.forAll[org.eclipse.uml2.uml.Classifier c|_self.maySpecializeType(c)]
      

// --- invariant maps_to_generalization_set
// --- category INV_FORALL
// OCL --- The Classifier that maps to a GeneralizationSet may neither be a specific nor a general Classifier in any of the Generalization relationships defined for that GeneralizationSet. In other words, a power type may not be an instance of itself nor may its instances also be its subclasses.
// INV --- powertypeExtent->forAll( gs | 
// INV ---   gs.generalization->forAll( gen | 
// INV ---     not (gen.general = self) and not gen.general.allParents()->includes(self) and not (gen.specific = self) and not self.allParents()->includes(gen.specific) 
// INV ---   ))
invariant maps_to_generalization_set (uml.GeneralizationSet gs)
context uml.Classifier
check _self.powertypeExtents.forAll[org.eclipse.uml2.uml.GeneralizationSet gs|
	gs.generalizations.forAll[gen|
		gen.general != _self && !gen.general.allParents.includes(_self) 
			&& gen.specific != _self && !_self.allParents.includes(gen.specific)
	]
]
      

// --- invariant non_final_parents
// --- category INV_FORALL
// OCL --- The parents of a Classifier must be non-final.
// INV --- parents()->forAll(not isFinalSpecialization)
invariant non_final_parents (uml.Classifier c)
context uml.Class
check _self.parents.forAll[org.eclipse.uml2.uml.Classifier c|!c.isFinalSpecialization]
      

// --- invariant no_cycles_in_generalization
// --- category INV_EXISTS*
// OCL --- Generalization hierarchies must be directed and acyclical. A Classifier can not be both a transitively general and transitively specific Classifier of the same Classifier.
// INV --- not allParents()->includes(self)
invariant no_cycles_in_generalization (uml.Classifier c)
context uml.Class
check !_self.parents.exists[org.eclipse.uml2.uml.Classifier c|c == _self]
      
// --- --- --- class --- Namespace */

// --- invariant members_distinguishable
// --- category ATTR
// OCL --- All the members of a Namespace are distinguishable within it.
// INV --- membersAreDistinguishable()
      

// --- invariant cannot_import_self
// --- category INV_MAP_EXISTS*
// OCL --- A Namespace cannot have a PackageImport to itself.
// INV --- packageImport.importedPackage.oclAsType(Namespace)->excludes(self)
invariant cannot_import_self (uml.PackageImport pi, uml.Package ns)
context uml.Namespace
check !_self.packageImports.map[org.eclipse.uml2.uml.PackageImport pi|pi.importedPackage]
	.exists[org.eclipse.uml2.uml.Package ns|ns == _self]
      

// --- invariant cannot_import_ownedMembers
// --- category INV_MAP_FORALL*
// OCL --- A Namespace cannot have an ElementImport to one of its ownedMembers.
// INV --- elementImport.importedElement.oclAsType(Element)->excludesAll(ownedMember)
invariant cannot_import_ownedMembers (uml.ElementImport ei)
context uml.Namespace
check _self.elementImports.map[org.eclipse.uml2.uml.ElementImport ei|ei.importedElement]
	.forAll[org.eclipse.uml2.uml.PackageableElement e|_self.ownedMembers.excludes(e)]
      
// --- --- --- class --- NamedElement */

// --- invariant visibility_needs_ownership
// --- category ATTR
// OCL --- If a NamedElement is owned by something other than a Namespace, it does not have a visibility. One that is not owned by anything (and hence must be a Package, as this is the only kind of NamedElement that overrides mustBeOwned()) may have a visibility.
// INV --- (namespace = null and owner <> null) implies visibility = null
      

// --- invariant has_qualified_name
// --- category IGN_COMPLEX
// OCL --- When there is a name, and all of the containing Namespaces have a name, the qualifiedName is constructed from the name of the NamedElement and the names of the containing Namespaces.
// INV --- (name <> null and allNamespaces()->select(ns | ns.name = null)->isEmpty()) implies
// INV ---   qualifiedName = allNamespaces()->iterate( ns : Namespace; agg: String = name | ns.name.concat(self.separator()).concat(agg))
      

// --- invariant has_no_qualified_name 
// --- category INV_EXISTS*
// OCL --- If there is no name, or one of the containing Namespaces has no name, there is no qualifiedName.
// INV --- name=null or allNamespaces()->select( ns | ns.name=null )->notEmpty() implies qualifiedName = null
invariant has_no_qualified_name (uml.Namespace ns)
context uml.NamedElement
check _self.qualifiedName == null || (_self.name != null 
	&& !_self.allNamespaces.exists[org.eclipse.uml2.uml.Namespace ns|ns.name == null]
)
      
// --- --- --- class --- Element */

// --- invariant has_owner 
// --- category ATTR
// OCL --- Elements that must be owned must have an owner.
// INV --- mustBeOwned() implies owner->notEmpty()
      

// --- invariant not_own_self 
// --- category INV_EXISTS* 
// OCL --- An element may not directly or indirectly own itself.
// INV --- not allOwnedElements()->includes(self)
invariant not_own_self (uml.Element e)
context uml.Element
check !_self.allOwnedElements.exists[org.eclipse.uml2.uml.Element e|e == _self]
      
// --- --- --- class --- Stereotype */

// --- invariant binaryAssociationsOnly 
// --- category INV_MAP_FORALL
// OCL --- Stereotypes may only participate in binary associations.
// INV --- ownedAttribute.association->forAll(memberEnd->size()=2)
invariant binaryAssociationsOnly (uml.Property p, uml.Association a)
context uml.Stereotype
check _self.ownedAttributes.map[org.eclipse.uml2.uml.Property p|p.association]
	.forAll[org.eclipse.uml2.uml.Association a|a.memberEnds.size == 2]
      

// --- invariant generalize 
// --- category IGN_ILLEGAL
// OCL --- A Stereotype may only generalize or specialize another Stereotype.
// INV --- allParents()->forAll(oclIsKindOf(Stereotype)) 
// INV --- and Classifier.allInstances()->forAll(c | c.allParents()->exists(oclIsKindOf(Stereotype)) implies c.oclIsKindOf(Stereotype))
      

// --- invariant name_not_clash 
// --- category IGN_TEXTUAL 
// OCL --- Stereotype names should not clash with keyword names for the extended model element.
      

// --- invariant associationEndOwnership 
// --- category INV_SELECT_FORALL
// OCL --- Where a stereotype’s property is an association end for an association other than a kind of extension, and the other end is not a stereotype, the other end must be owned by the association itself.
// INV --- ownedAttribute
// INV --- ->select(association->notEmpty() and not association.oclIsKindOf(Extension) and not type.oclIsKindOf(Stereotype))
// INV --- ->forAll(opposite.owner = association)
invariant associationEndOwnership (uml.Property a, uml.Property p)
context uml.Stereotype
check _self.ownedAttributes.select[org.eclipse.uml2.uml.Property a|
	a.association != null && !a.association.oclIsKindOf(org.eclipse.uml2.uml.Extension) && !a.type.oclIsKindOf(org.eclipse.uml2.uml.Stereotype)
].forAll[org.eclipse.uml2.uml.Property p|p.opposite.owner == p.association]


// --- invariant base_property_upper_bound 
// --- category IGN_TEXTUAL 
// OCL --- The upper bound of base-properties is exactly 1.
      

// --- invariant base_property_multiplicity_single_extension 
// --- category IGN_TEXTUAL 
// OCL --- If a Stereotype extends only one metaclass, the multiplicity of the corresponding base-property shall be 1..1.
      

// --- invariant base_property_multiplicity_multiple_extension 
// --- category IGN_TEXTUAL 
// OCL --- If a Stereotype extends more than one metaclass, the multiplicity of the corresponding base-properties shall be [0..1]. At any point in time, only one of these base-properties can contain a metaclass instance during runtime.
      
// --- --- --- class --- Profile */

// --- invariant metaclass_reference_not_specialized
// --- category IGN_COMPLEX
// OCL --- An element imported as a metaclassReference is not specialized or generalized in a Profile.
// INV --- metaclassReference.importedElement->
// INV ---   select(c | c.oclIsKindOf(Classifier) and
// INV ---     (c.oclAsType(Classifier).allParents()->collect(namespace)->includes(self)))->isEmpty()
// INV --- and 
// INV --- packagedElement->
// INV ---     select(oclIsKindOf(Classifier))->collect(oclAsType(Classifier).allParents())->
// INV ---        intersection(metaclassReference.importedElement->select(oclIsKindOf(Classifier))->collect(oclAsType(Classifier)))->isEmpty()
      

// --- invariant references_same_metamodel
// --- category IGN_COMPLEX
// OCL --- All elements imported either as metaclassReferences or through metamodelReferences are members of the same base reference metamodel.
// INV --- metamodelReference.importedPackage.elementImport.importedElement.allOwningPackages()->
// INV ---   union(metaclassReference.importedElement.allOwningPackages() )->notEmpty()
      
// --- --- --- class --- Package */

// --- invariant elements_public_or_private 
// --- category INV_FORALL
// OCL --- If an element that is owned by a package has visibility, it is public or private.
// INV --- packagedElement->forAll(e | e.visibility<> null implies e.visibility = VisibilityKind::public or e.visibility = VisibilityKind::private)
invariant elements_public_or_private (uml.PackageableElement e)
context uml.Package
check _self.packagedElements.forAll[org.eclipse.uml2.uml.PackageableElement e|
	(e.visibility != null).implies(e.visibility == org.eclipse.uml2.uml.VisibilityKind.PUBLIC || e.visibility == org.eclipse.uml2.uml.VisibilityKind.PRIVATE)
]    
      
// --- --- --- class --- PackageableElement */

// --- invariant namespace_needs_visibility 
// --- category ATTR 
// OCL --- A PackageableElement owned by a Namespace must have a visibility.
// INV --- visibility = null implies namespace = null
      
// --- --- --- class --- TemplateParameter */

// --- invariant must_be_compatible 
// --- category ATTR 
// OCL --- The default must be compatible with the formal TemplateParameter.
// INV --- default <> null implies default.isCompatibleWith(parameteredElement)
      
// --- --- --- class --- TemplateSignature */

// --- invariant own_elements
// --- category IGN_COMPLEX
// OCL --- Parameters must own the ParameterableElements they parameter or those ParameterableElements must be owned by the TemplateableElement being templated.
// INV --- template.ownedElement->includesAll(parameter.parameteredElement->asSet() - parameter.ownedParameteredElement->asSet())
         

// --- invariant unique_parameters
// --- category INV_UNIQUE
// OCL --- The names of the parameters of a TemplateSignature are unique.
// INV --- parameter->forAll( p1, p2 | (p1 <> p2 and p1.parameteredElement.oclIsKindOf(NamedElement) and p2.parameteredElement.oclIsKindOf(NamedElement) ) implies
// INV ---    p1.parameteredElement.oclAsType(NamedElement).name <> p2.parameteredElement.oclAsType(NamedElement).name)
invariant unique_parameters
context uml.TemplateSignature
check _self.parameters.filterType(org.eclipse.uml2.uml.NamedElement).unique[e|e.name]     
      
// --- --- --- class --- TemplateBinding */

// --- invariant parameter_substitution_formal 
// --- category INV_FORALL 
// OCL --- Each parameterSubstitution must refer to a formal TemplateParameter of the target TemplateSignature.
// INV --- parameterSubstitution->forAll(b | signature.parameter->includes(b.formal))
invariant parameter_substitution_formal (uml.TemplateParameterSubstitution p)
context uml.TemplateBinding
check _self.parameterSubstitutions.forAll[org.eclipse.uml2.uml.TemplateParameterSubstitution p|
	_self.signature.parameters.includes(p.formal)
]
      

// --- invariant one_parameter_substitution
// --- category INV_FORALL
// OCL --- A TemplateBiinding contains at most one TemplateParameterSubstitution for each formal TemplateParameter of the target TemplateSignature.
// INV --- signature.parameter->forAll(p | parameterSubstitution->select(b | b.formal = p)->size() <= 1)
invariant one_parameter_substitution (uml.TemplateParameter p)
context uml.TemplateBinding
check _self.signature.parameters.forAll[org.eclipse.uml2.uml.TemplateParameter p|
	_self.parameterSubstitutions.select[b|b.formal == p].size <= 1
]

// --- --- --- class --- TemplateParameterSubstitution */

// --- invariant must_be_compatible 
// --- category ATTR 
// OCL --- The actual ParameterableElement must be compatible with the formal TemplateParameter, e.g., the actual ParameterableElement for a Class TemplateParameter must be a Class.
// INV --- actual->forAll(a | a.isCompatibleWith(formal.parameteredElement))
      
// --- --- --- class --- Association */

// --- invariant specialized_end_number 
// --- category INV_FORALL 
// OCL --- An Association specializing another Association has the same number of ends as the other Association.
// INV --- parents()->select(oclIsKindOf(Association)).oclAsType(Association)->forAll(p | p.memberEnd->size() = self.memberEnd->size())
invariant specialized_end_number (uml.Association p)
context uml.Association
check _self.parents.filterType(org.eclipse.uml2.uml.Association)
	.forAll[org.eclipse.uml2.uml.Association p|p.memberEnds.size == _self.memberEnds.size]
     

// --- invariant specialized_end_types
// --- category IGN_COMPLEX
// OCL --- When an Association specializes another Association, every end of the specific Association corresponds to an end of the general Association, and the specific end reaches the same type or a subtype of the corresponding general end.
// INV --- Sequence{1..memberEnd->size()}->
// INV ---   forAll(i | general->select(oclIsKindOf(Association)).oclAsType(Association)->
// INV ---     forAll(ga | self.memberEnd->at(i).type.conformsTo(ga.memberEnd->at(i).type)))
      

// --- invariant binary_associations 
// --- category INV_EXISTS* 
// OCL --- Only binary Associations can be aggregations.
// INV --- memberEnd->exists(aggregation <> AggregationKind::none) implies (memberEnd->size() = 2 and memberEnd->exists(aggregation = AggregationKind::none))
invariant binary_associations (uml.Property p, uml.Property p2)
context uml.Association
check !_self.memberEnds.exists[org.eclipse.uml2.uml.Property p|
	p.aggregation != org.eclipse.uml2.uml.AggregationKind.NONE
] || (_self.memberEnds.size == 2 && _self.memberEnds.exists[org.eclipse.uml2.uml.Property p2|
	p2.aggregation == org.eclipse.uml2.uml.AggregationKind.NONE
])
      

// --- invariant association_ends 
// --- category INV_FORALL* 
// OCL --- Ends of Associations with more than two ends must be owned by the Association itself.
// INV --- memberEnd->size() > 2 implies ownedEnd->includesAll(memberEnd)
invariant association_ends (uml.Property p)
context uml.Association
check _self.memberEnds.size <= 2 || _self.memberEnds.forAll[org.eclipse.uml2.uml.Property p|_self.ownedEnds.includes(p)]
      

// --- invariant ends_must_be_typed 
// --- category INV_FORALL 
// OCL --- 
// INV --- memberEnd->forAll(type->notEmpty())
invariant ends_must_be_typed (uml.Property p)
context uml.Association
check _self.memberEnds.forAll[org.eclipse.uml2.uml.Property p|p.type != null]
     
// --- --- --- class --- Property */

// --- invariant subsetting_context_conforms
// --- category INV_FORALL
// OCL --- Subsetting may only occur when the  of the subsetting property conforms to the  of the subsetted property.
// INV --- subsettedProperty->notEmpty() implies
// INV ---   (subsettingContext()->notEmpty() and subsettingContext()->forAll (sc |
// INV ---     subsettedProperty->forAll(sp |
// INV ---       sp.subsettingContext()->exists(c | sc.conformsTo(c)))))
invariant subsetting_context_conforms (uml.Type sc)
context uml.Property
check _self.subsettedProperties.empty || (_self.subsettingContext.notEmpty 
	&& _self.subsettingContext.forAll[org.eclipse.uml2.uml.Type sc|
		_self.subsettedProperties.forAll[sp|sp.subsettingContext.exists[c|sc.conformsTo(c)]]
	]
)
      

// --- invariant derived_union_is_read_only 
// --- category ATTR 
// OCL --- A derived union is read only.
// INV --- isDerivedUnion implies isReadOnly
      

// --- invariant multiplicity_of_composite 
// --- category ATTR 
// OCL --- A multiplicity on the composing end of a composite aggregation must not have an upper bound greater than 1.
// INV --- isComposite and association <> null implies opposite.upperBound() <= 1
      

// --- invariant redefined_property_inherited
// --- category INV_FORALL
// OCL --- A redefined Property must be inherited from a more general Classifier.
// INV --- (redefinedProperty->notEmpty()) implies
// INV ---   (redefinitionContext->notEmpty() and
// INV ---       redefinedProperty->forAll(rp|
// INV ---         ((redefinitionContext->collect(fc|
// INV ---           fc.allParents()))->asSet())->collect(c| c.allFeatures())->asSet()->includes(rp)))
invariant redefined_property_inherited
context uml.Property
check _self.redefinedProperties.empty || (_self.redefinitionContexts.notEmpty 
	&& _self.redefinedProperties.forAll[org.eclipse.uml2.uml.Property rp|
		_self.redefinitionContexts.map[fc|fc.allParents].flatten.asSet
			.map[c|c.allFeatures].flatten.asSet.includes(rp)
	]
)
      

// --- invariant subsetting_rules 
// --- category INV_FORALL
// OCL --- A subsetting Property may strengthen the type of the subsetted Property, and its upper bound may be less.
// INV --- subsettedProperty->forAll(sp |
// INV ---   self.type.conformsTo(sp.type) and
// INV ---     ((self.upperBound()->notEmpty() and sp.upperBound()->notEmpty()) implies
// INV ---       self.upperBound() <= sp.upperBound() ))
invariant subsetting_rules (uml.Property p)
context uml.Property
check _self.subsettedProperties.forAll[org.eclipse.uml2.uml.Property p |
	_self.type.conformsTo(p.type) && ((_self.upperBound != 0 && p.upperBound != 0)
			.implies(_self.upperBound <= p.upperBound)
	)
]
      

// --- invariant binding_to_attribute
// --- category IGN_ILLEGAL
// OCL --- A binding of a PropertyTemplateParameter representing an attribute must be to an attribute.
// INV --- (self.isAttribute()
// INV --- and (templateParameterSubstitution->notEmpty())
// INV --- implies (templateParameterSubstitution->forAll(ts |
// INV ---     ts.formal.oclIsKindOf(Property)
// INV ---     and ts.formal.oclAsType(Property).isAttribute())))

// --- invariant derived_union_is_derived 
// --- category ATTR 
// OCL --- A derived union is derived.
// INV --- isDerivedUnion implies isDerived
      

// --- invariant deployment_target
// --- category IGN_ILLEGAL
// OCL --- A Property can be a DeploymentTarget if it is a kind of Node and functions as a part in the internal structure of an encompassing Node.
// INV --- deployment->notEmpty() implies owner.oclIsKindOf(Node) and Node.allInstances()->exists(n | n.part->exists(p | p = self))
      

// --- invariant subsetted_property_names 
// --- category INV_FORALL 
// OCL --- A Property may not subset a Property with the same name.
// INV --- subsettedProperty->forAll(sp | sp.name <> name)
invariant subsetted_property_names (uml.Property p)
context uml.Property
check _self.subsettedProperties.forAll[org.eclipse.uml2.uml.Property p|p.name != _self.name]


// --- invariant type_of_opposite_end 
// --- category ATTR 
// OCL --- If a Property is a classifier-owned end of a binary Association, its owner must be the type of the opposite end.
// INV --- (opposite->notEmpty() and owningAssociation->isEmpty()) implies classifier = opposite.type
      

// --- invariant qualified_is_association_end 
// --- category ATTR 
// OCL --- All qualified Properties must be Association ends
// INV --- qualifier->notEmpty() implies association->notEmpty()
      
// --- --- --- class --- ConnectorEnd */

// --- invariant role_and_part_with_port
// --- category INV_EXISTS*
// OCL --- If a ConnectorEnd references a partWithPort, then the role must be a Port that is defined or inherited by the type of the partWithPort.
// INV --- partWithPort->notEmpty() implies 
// INV ---   (role.oclIsKindOf(Port) and partWithPort.type.oclAsType(Namespace).member->includes(role))
invariant role_and_part_with_port (uml.NamedElement e)
context uml.ConnectorEnd
check _self.partWithPort == null || (_self.role.oclIsKindOf(org.eclipse.uml2.uml.Port) 
	&& _self.partWithPort.type.oclAsType(org.eclipse.uml2.uml.Namespace).members
		.exists[org.eclipse.uml2.uml.NamedElement e|e == _self.role]
)
      

// --- invariant part_with_port_empty 
// --- category ATTR 
// OCL --- If a ConnectorEnd is attached to a Port of the containing Classifier, partWithPort will be empty.
// INV --- (role.oclIsKindOf(Port) and role.owner = connector.owner) implies partWithPort->isEmpty()
      

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the ConnectorEnd may not be more general than the multiplicity of the corresponding end of the Association typing the owning Connector, if any.
// INV --- self.compatibleWith(definingEnd)
      

// --- invariant self_part_with_port 
// --- category ATTR 
// OCL --- The Property held in self.partWithPort must not be a Port.
// INV --- partWithPort->notEmpty() implies not partWithPort.oclIsKindOf(Port)

// --- --- --- class --- MultiplicityElement

// --- invariant upper_ge_lower 
// --- category ATTR 
// OCL --- The upper bound must be greater than or equal to the lower bound.
// INV --- upperBound() >= lowerBound()
      

// --- invariant lower_ge_0 
// --- category ATTR 
// OCL --- The lower bound must be a non-negative integer literal.
// INV --- lowerBound() >= 0
      

// --- invariant value_specification_no_side_effects 
// --- category IGN_TEXTUAL 
// OCL --- If a non-literal ValueSpecification is used for lowerValue or upperValue, then evaluating that specification must not have side effects.
      

// --- invariant value_specification_constant 
// --- category IGN_TEXTUAL 
// OCL --- If a non-literal ValueSpecification is used for lowerValue or upperValue, then that specification must be a constant expression.
      

// --- invariant lower_is_integer 
// --- category ATTR 
// OCL --- If it is not empty, then lowerValue must have an Integer value.
// INV --- lowerValue <> null implies lowerValue.integerValue() <> null
      

// --- invariant upper_is_unlimitedNatural 
// --- category ATTR 
// OCL --- If it is not empty, then upperValue must have an UnlimitedNatural value.
// INV --- upperValue <> null implies upperValue.unlimitedValue() <> null
    
// --- --- --- class --- DeploymentSpecification */

// --- invariant deployment_target 
// --- category ATTR 
// OCL --- The DeploymentTarget of a DeploymentSpecification is a kind of ExecutionEnvironment.
// INV --- deployment->forAll (location.oclIsKindOf(ExecutionEnvironment))


// --- invariant deployed_elements 
// --- category INV_FORALL 
// OCL --- The deployedElements of a DeploymentTarget that are involved in a Deployment that has an associated Deployment-Specification is a kind of Component (i.e., the configured components).
// INV --- deployment->forAll (location.deployedElement->forAll (oclIsKindOf(Component)))
invariant deployed_elements (uml.PackageableElement e)
context uml.DeploymentSpecification
check _self.deployment.location.deployedElements
	.forAll[org.eclipse.uml2.uml.PackageableElement e|e.oclIsKindOf(org.eclipse.uml2.uml.Component)]
      
// --- --- --- class --- OpaqueExpression */

// --- invariant language_body_size
// --- category SIZE
// OCL --- If the language attribute is not empty, then the size of the body and language arrays must be the same.
// INV --- language->notEmpty() implies (_'body'->size() = language->size())
      

// --- invariant one_return_result_parameter
// --- category SIZE
// OCL --- The behavior must have exactly one return result parameter.
// INV --- behavior <> null implies
// INV ---    behavior.ownedParameter->select(direction=ParameterDirectionKind::return)->size() = 1
      

// --- invariant only_return_result_parameters 
// --- category INV_FORALL* 
// OCL --- The behavior may only have return result parameters.
// INV --- behavior <> null implies behavior.ownedParameter->select(direction<>ParameterDirectionKind::return)->isEmpty()
invariant only_return_result_parameters (uml.Parameter p)
context uml.OpaqueExpression
check _self.behavior == null || _self.behavior.ownedParameters
	.forAll[org.eclipse.uml2.uml.Parameter p|p.direction == org.eclipse.uml2.uml.ParameterDirectionKind.RETURN]    
      
// --- --- --- class --- Parameter */

// --- invariant in_and_out 
// --- category ATTR 
// OCL --- Only in and inout Parameters may have a delete effect. Only out, inout, and return Parameters may have a create effect.
// INV --- (effect = ParameterEffectKind::delete implies (direction = ParameterDirectionKind::_'in' or direction = ParameterDirectionKind::inout))
// INV --- and
// INV --- (effect = ParameterEffectKind::create implies (direction = ParameterDirectionKind::out or direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::return))
      

// --- invariant not_exception 
// --- category ATTR 
// OCL --- An input Parameter cannot be an exception.
// INV --- isException implies (direction <> ParameterDirectionKind::_'in' and direction <> ParameterDirectionKind::inout)
      

// --- invariant connector_end 
// --- category ATTR 
// OCL --- A Parameter may only be associated with a Connector end within the  of a Collaboration.
// INV --- end->notEmpty() implies collaboration->notEmpty()
      

// --- invariant reentrant_behaviors 
// --- category ATTR 
// OCL --- Reentrant behaviors cannot have stream Parameters.
// INV --- (isStream and behavior <> null) implies not behavior.isReentrant
       

// --- invariant stream_and_exception 
// --- category ATTR 
// OCL --- A Parameter cannot be a stream and exception at the same time.
// INV --- not (isException and isStream)
      

// --- invariant object_effect 
// --- category ATTR 
// OCL --- Parameters typed by DataTypes cannot have an effect.
// INV --- (type.oclIsKindOf(DataType)) implies (effect = null)
      
// --- --- --- class --- Operation */

// --- invariant at_most_one_return
// --- category SIZE
// OCL --- An Operation can have at most one return parameter; i.e., an owned parameter with the direction set to 'return.'
// INV --- self.ownedParameter->select(direction = ParameterDirectionKind::return)->size() <= 1
      

// --- invariant only_body_for_query 
// --- category ATTR 
// OCL --- A bodyCondition can only be specified for a query Operation.
// INV --- bodyCondition <> null implies isQuery
      
// --- --- --- class --- BehavioralFeature */

// --- invariant abstract_no_method 
// --- category SIZE 
// OCL --- When isAbstract is true there are no methods.
// INV --- isAbstract implies method->isEmpty()
      
// --- --- --- class --- RedefinableElement */

// --- invariant redefinition_consistent 
// --- category INV_FORALL 
// OCL --- A redefining element must be consistent with each redefined element.
// INV --- redefinedElement->forAll(re | re.isConsistentWith(self))
invariant redefinition_consistent (uml.RedefinableElement e)
context uml.RedefinableElement
check _self.redefinedElements.forAll[org.eclipse.uml2.uml.RedefinableElement e|e.isConsistentWith(_self)]
      

// --- invariant non_leaf_redefinition 
// --- category INV_FORALL 
// OCL --- A RedefinableElement can only redefine non-leaf RedefinableElements.
// INV --- redefinedElement->forAll(re | not re.isLeaf)
invariant non_leaf_redefinition (uml.RedefinableElement e)
context uml.RedefinableElement
check _self.redefinedElements.forAll[org.eclipse.uml2.uml.RedefinableElement e|!e.isLeaf]
      

// --- invariant redefinition_context_valid 
// --- category INV_FORALL 
// OCL --- At least one of the redefinition contexts of the redefining element must be a specialization of at least one of the redefinition contexts for each redefined element.
// INV --- redefinedElement->forAll(re | self.isRedefinitionContextValid(re))
invariant redefinition_context_valid (uml.RedefinableElement e)
context uml.RedefinableElement
check _self.redefinedElements.forAll[org.eclipse.uml2.uml.RedefinableElement e|_self.isRedefinitionContextValid(e)]
      
// --- --- --- class --- ParameterSet */

// --- invariant same_parameterized_entity 
// --- category INV_FORALL*
// OCL --- The Parameters in a ParameterSet must all be inputs or all be outputs of the same parameterized entity, and the ParameterSet is owned by that entity.
// INV --- parameter->forAll(p1, p2 | self.owner = p1.owner and self.owner = p2.owner and p1.direction = p2.direction)
 invariant same_parameterized_entity (uml.Parameter p1, uml.Parameter p2, uml.Parameter p3)
 context uml.ParameterSet
 check _self.parameters.forAll[org.eclipse.uml2.uml.Parameter p1|p1.owner == _self.owner]
 	&& (_self.parameters.forAll[org.eclipse.uml2.uml.Parameter p2|p2.direction == org.eclipse.uml2.uml.ParameterDirectionKind.IN]
 	|| _self.parameters.forAll[org.eclipse.uml2.uml.Parameter p3|p3.direction == org.eclipse.uml2.uml.ParameterDirectionKind.OUT])
      

// --- invariant input
// --- category IGN_COMPLEX
// OCL --- If a parameterized entity has input Parameters that are in a ParameterSet, then any inputs that are not in a ParameterSet must be streaming. Same for output Parameters.
// INV --- ((parameter->exists(direction = ParameterDirectionKind::_'in')) implies 
// INV ---     behavioralFeature.ownedParameter->select(p | p.direction = ParameterDirectionKind::_'in' and p.parameterSet->isEmpty())->forAll(isStream))
// INV ---     and
// INV --- ((parameter->exists(direction = ParameterDirectionKind::out)) implies 
// INV ---     behavioralFeature.ownedParameter->select(p | p.direction = ParameterDirectionKind::out and p.parameterSet->isEmpty())->forAll(isStream))
      

// --- invariant two_parameter_sets
// --- category INV_FORALL*
// OCL --- Two ParameterSets cannot have exactly the same set of Parameters.
// INV --- parameter->forAll(parameterSet->forAll(s1, s2 | s1->size() = s2->size() implies s1.parameter->exists(p | not s2.parameter->includes(p))))
 invariant two_parameter_sets (uml.Parameter p)
 context uml.ParameterSet
 check _self.parameters.forAll[org.eclipse.uml2.uml.Parameter p|
 	p.parameterSets.forAll[s1, s2|
 		(s1.parameters.size == s2.parameters.size).implies(
 			s1.parameters.exists[p2|!s2.parameters.includes(p2)]
 		)
 	]
 ]
      
// --- --- --- class --- Constraint */

// --- invariant boolean_value 
// --- category IGN_TEXTUAL 
// OCL --- The ValueSpecification for a Constraint must evaluate to a Boolean value.
      

// --- invariant no_side_effects 
// --- category IGN_TEXTUAL 
// OCL --- Evaluating the ValueSpecification for a Constraint must not have side effects.
      

// --- invariant not_apply_to_self 
// --- category INV_EXISTS* 
// OCL --- A Constraint cannot be applied to itself.
// INV --- not constrainedElement->includes(self)
invariant not_apply_to_self (uml.Element e)
context uml.Constraint
check _self.constrainedElements.exists[org.eclipse.uml2.uml.Element e|e == _self]
      
// --- --- --- class --- Interface */

// --- invariant visibility 
// --- category INV_FORALL 
// OCL --- The visibility of all Features owned by an Interface must be public.
// INV --- feature->forAll(visibility = VisibilityKind::public)
invariant visibility
context uml.Interface
check _self.features.forAll[org.eclipse.uml2.uml.Feature f|f.visibility == org.eclipse.uml2.uml.VisibilityKind.PUBLIC]
      
// --- --- --- class --- Reception */

// --- invariant same_name_as_signal 
// --- category ATTR 
// OCL --- A Reception has the same name as its signal
// INV --- name = signal.name
      

// --- invariant same_structure_as_signal 
// --- category IGN_COMPLEX
// OCL --- A Reception's parameters match the ownedAttributes of its signal by name, type, and multiplicity
// INV --- signal.ownedAttribute->size() = ownedParameter->size() and
// INV --- Sequence{1..signal.ownedAttribute->size()}->forAll( i | 
// INV ---     ownedParameter->at(i).direction = ParameterDirectionKind::_'in' and 
// INV ---     ownedParameter->at(i).name = signal.ownedAttribute->at(i).name and
// INV ---     ownedParameter->at(i).type = signal.ownedAttribute->at(i).type and
// INV ---     ownedParameter->at(i).lowerBound() = signal.ownedAttribute->at(i).lowerBound() and
// INV ---     ownedParameter->at(i).upperBound() = signal.ownedAttribute->at(i).upperBound()
// INV --- )
      
// --- --- --- class --- ProtocolStateMachine */

// --- invariant classifier_context 
// --- category ATTR 
// OCL --- A ProtocolStateMachine must only have a Classifier , not a BehavioralFeature .
// INV --- _'' <> null and specification = null
   

// --- invariant deep_or_shallow_history
// --- category INV_FORALL
// OCL --- ProtocolStateMachines cannot have deep or shallow history Pseudostates.
// INV --- region->forAll (r | r.subvertex->forAll (v | v.oclIsKindOf(Pseudostate) implies
// INV --- ((v.oclAsType(Pseudostate).kind <>  PseudostateKind::deepHistory) and (v.oclAsType(Pseudostate).kind <> PseudostateKind::shallowHistory))))
invariant deep_or_shallow_history (uml.Region r)
context uml.ProtocolStateMachine
check _self.regions.forAll[org.eclipse.uml2.uml.Region r|
	r.subvertices.forAll[v|
		!v.oclIsKindOf(org.eclipse.uml2.uml.Pseudostate) || 
		(v.oclAsType(org.eclipse.uml2.uml.Pseudostate).kind != org.eclipse.^ocl.pivot.PseudostateKind.DEEP_HISTORY 
			&& v.oclAsType(org.eclipse.uml2.uml.Pseudostate).kind != org.eclipse.^ocl.pivot.PseudostateKind.DEEP_HISTORY)
	]
]      

// --- invariant entry_exit_do
// --- category INV_FORALL
// OCL --- The states of a ProtocolStateMachine cannot have entry, exit, or do activity Behaviors.
// INV --- region->forAll(r | r.subvertex->forAll(v | v.oclIsKindOf(State) implies
// INV --- (v.oclAsType(State).entry->isEmpty() and v.oclAsType(State).exit->isEmpty() and v.oclAsType(State).doActivity->isEmpty())))
   invariant entry_exit_do (uml.Region r)
context uml.ProtocolStateMachine
check _self.regions.forAll[org.eclipse.uml2.uml.Region r|
	r.subvertices.forAll[v|
		!v.oclIsKindOf(org.eclipse.uml2.uml.State) || 
		(v.oclAsType(org.eclipse.uml2.uml.State).entry == null 
			&& v.oclAsType(org.eclipse.uml2.uml.State).exit == null
			&& v.oclAsType(org.eclipse.uml2.uml.State).doActivity == null)
	]
]     

// --- invariant protocol_transitions 
// --- category INV_MAP_FORALL 
// OCL --- All Transitions of a ProtocolStateMachine must be ProtocolTransitions.
// INV --- region->forAll(r | r.transition->forAll(t | t.oclIsTypeOf(ProtocolTransition)))
invariant protocol_transitions (uml.Transition t)
context uml.ProtocolStateMachine
check _self.regions.map[r|r.transitions].flatten
	.forAll[org.eclipse.uml2.uml.Transition t|t.oclIsKindOf(org.eclipse.uml2.uml.ProtocolTransition)]
      
// --- --- --- class --- StateMachine */

// --- invariant connection_points 
// --- category INV_FORALL 
// OCL --- The connection points of a StateMachine are Pseudostates of kind entry point or exit point.
// INV --- connectionPoint->forAll (kind = PseudostateKind::entryPoint or kind = PseudostateKind::exitPoint)
invariant connection_points (uml.Pseudostate s)
context uml.StateMachine
check _self.connectionPoints.forAll[org.eclipse.uml2.uml.Pseudostate s|
	s.kind == org.eclipse.uml2.uml.PseudostateKind.ENTRY_POINT ||
	s.kind == org.eclipse.uml2.uml.PseudostateKind.EXIT_POINT
]
      

// --- invariant classifier_context 
// --- category ATTR 
// OCL --- The Classifier  of a StateMachine cannot be an Interface.
// INV --- _'' <> null implies not _''.oclIsKindOf(Interface)
    

// --- invariant method 
// --- category SIZE 
// OCL --- A StateMachine as the method for a BehavioralFeature cannot have entry/exit connection points.
// INV --- specification <> null implies connectionPoint->isEmpty()
      

// --- invariant context_classifier 
// --- category INV_EXISTS 
// OCL --- The  Classifier of the method StateMachine of a BehavioralFeature must be the Classifier that owns the BehavioralFeature.
// INV --- specification <> null implies ( _'' <> null and specification.featuringClassifier->exists(c | c = _''))
invariant context_classifier (uml.Classifier c)
context uml.StateMachine
check _self.specification == null ||
	_self.specification.featuringClassifiers.exists[org.eclipse.uml2.uml.Classifier c|c == _self]
      
// --- --- --- class --- Pseudostate */

// --- invariant transitions_outgoing
// --- category IGN_COMPLEX
// OCL --- All transitions outgoing a fork vertex must target states in different regions of an orthogonal state.
// INV --- (kind = PseudostateKind::fork) implies
// INV --- 
// INV --- -- for any pair of outgoing transitions there exists an orthogonal state which contains the targets of these transitions 
// INV --- -- such that these targets belong to different regions of that orthogonal state 
// INV --- 
// INV --- outgoing->forAll(t1:Transition, t2:Transition | let contState:State = containingStateMachine().LCAState(t1.target, t2.target) in
// INV ---   ((contState <> null) and (contState.region
// INV ---     ->exists(r1:Region, r2: Region | (r1 <> r2) and t1.target.isContainedInRegion(r1) and t2.target.isContainedInRegion(r2)))))
      

// --- invariant choice_vertex
// --- category SIZE
// OCL --- In a complete statemachine, a choice Vertex must have at least one incoming and one outgoing Transition.
// INV --- (kind = PseudostateKind::choice) implies (incoming->size() >= 1 and outgoing->size() >= 1)
      

// --- invariant outgoing_from_initial 
// --- category ATTR 
// OCL --- The outgoing Transition from an initial vertex may have a behavior, but not a trigger or a guard.
// INV --- (kind = PseudostateKind::initial) implies (outgoing.guard = null and outgoing.trigger->isEmpty())
      

// --- invariant join_vertex
// --- category SIZE
// OCL --- In a complete StateMachine, a join Vertex must have at least two incoming Transitions and exactly one outgoing Transition.
// INV --- (kind = PseudostateKind::join) implies (outgoing->size() = 1 and incoming->size() >= 2)
      

// --- invariant junction_vertex
// --- category SIZE
// OCL --- In a complete StateMachine, a junction Vertex must have at least one incoming and one outgoing Transition.
// INV --- (kind = PseudostateKind::junction) implies (incoming->size() >= 1 and outgoing->size() >= 1)
      

// --- invariant history_vertices
// --- category SIZE
// OCL --- History Vertices can have at most one outgoing Transition.
// INV --- ((kind = PseudostateKind::deepHistory) or (kind = PseudostateKind::shallowHistory)) implies (outgoing->size() <= 1)
      

// --- invariant initial_vertex
// --- category SIZE
// OCL --- An initial Vertex can have at most one outgoing Transition.
// INV --- (kind = PseudostateKind::initial) implies (outgoing->size() <= 1)
      

// --- invariant fork_vertex
// --- category SIZE
// OCL --- In a complete StateMachine, a fork Vertex must have at least two outgoing Transitions and exactly one incoming Transition.
// INV --- (kind = PseudostateKind::fork) implies (incoming->size() = 1 and outgoing->size() >= 2)
      

// --- invariant transitions_incoming
// --- category IGN_COMPLEX
// OCL --- All Transitions incoming a join Vertex must originate in different Regions of an orthogonal State.
// INV --- (kind = PseudostateKind::join) implies
// INV --- 
// INV --- -- for any pair of incoming transitions there exists an orthogonal state which contains the source vetices of these transitions 
// INV --- -- such that these source vertices belong to different regions of that orthogonal state 
// INV --- 
// INV --- incoming->forAll(t1:Transition, t2:Transition | let contState:State = containingStateMachine().LCAState(t1.source, t2.source) in
// INV ---   ((contState <> null) and (contState.region
// INV ---     ->exists(r1:Region, r2: Region | (r1 <> r2) and t1.source.isContainedInRegion(r1) and t2.source.isContainedInRegion(r2)))))
      
// --- --- --- class --- Region */

// --- invariant deep_history_vertex
// --- category SIZE
// OCL --- A Region can have at most one deep history Vertex.
// INV --- self.subvertex->select (oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))->
// INV ---    select(kind = PseudostateKind::deepHistory)->size() <= 1
      

// --- invariant shallow_history_vertex
// --- category SIZE
// OCL --- A Region can have at most one shallow history Vertex.
// INV --- subvertex->select(oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))->
// INV ---   select(kind = PseudostateKind::shallowHistory)->size() <= 1
      

// --- invariant owned 
// --- category ATTR 
// OCL --- If a Region is owned by a StateMachine, then it cannot also be owned by a State and vice versa.
// INV --- (stateMachine <> null implies state = null) and (state <> null implies stateMachine = null)
      

// --- invariant initial_vertex
// --- category SIZE
// OCL --- A Region can have at most one initial Vertex.
// INV --- self.subvertex->select (oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))->
// INV ---   select(kind = PseudostateKind::initial)->size() <= 1

// --- --- --- class --- State

// --- invariant entry_or_exit 
// --- category INV_FORALL 
// OCL --- Only entry or exit Pseudostates can serve as connection points.
// INV --- connectionPoint->forAll(kind = PseudostateKind::entryPoint or kind = PseudostateKind::exitPoint)
invariant entry_or_exit (uml.Pseudostate s)
context uml.State
check _self.connectionPoints.forAll[org.eclipse.uml2.uml.Pseudostate s|
	s.kind == org.eclipse.uml2.uml.PseudostateKind.ENTRY_POINT ||
	s.kind == org.eclipse.uml2.uml.PseudostateKind.EXIT_POINT
]
      

// --- invariant submachine_states 
// --- category ATTR 
// OCL --- Only submachine States can have connection point references.
// INV --- isSubmachineState implies connection->notEmpty( )
      

// --- invariant composite_states 
// --- category ATTR 
// OCL --- Only composite States can have entry or exit Pseudostates defined.
// INV --- connectionPoint->notEmpty() implies isComposite
      

// --- invariant destinations_or_sources_of_transitions 
// --- category INV_MAP_FORALL* 
// OCL --- The connection point references used as destinations/sources of Transitions associated with a submachine State must be defined as entry/exit points in the submachine StateMachine.
// INV --- self.isSubmachineState implies (self.connection->forAll (cp |
// INV ---   cp.entry->forAll (ps | ps.stateMachine = self.submachine) and
// INV ---   cp.exit->forAll (ps | ps.stateMachine = self.submachine)))
invariant destinations_or_sources_of_transitions (uml.Pseudostate en, uml.Pseudostate ex)
context uml.State
check !_self.isSubmachineState || 
	(_self.connections.map[cp|cp.entries].flatten.forAll[org.eclipse.uml2.uml.Pseudostate en|en.stateMachine == _self.submachine] &&
		_self.connections.map[cp2|cp2.exits].flatten.forAll[org.eclipse.uml2.uml.Pseudostate ex|ex.stateMachine == _self.submachine])
      

// --- invariant submachine_or_regions 
// --- category ATTR 
// OCL --- A State is not allowed to have both a submachine and Regions.
// INV --- isComposite implies not isSubmachineState
      
// --- --- --- class --- ConnectionPointReference */

// --- invariant exit_pseudostates 
// --- category INV_FORALL 
// OCL --- The exit Pseudostates must be Pseudostates with kind exitPoint.
// INV --- exit->forAll(kind = PseudostateKind::exitPoint)
invariant exit_pseudostates
context uml.ConnectionPointReference
check _self.exits.forAll[org.eclipse.uml2.uml.Pseudostate s|s.kind == org.eclipse.uml2.uml.PseudostateKind.EXIT_POINT]
      

// --- invariant entry_pseudostates 
// --- category INV_FORALL 
// OCL --- The entry Pseudostates must be Pseudostates with kind entryPoint.
// INV --- entry->forAll(kind = PseudostateKind::entryPoint)
invariant exit_pseudostates
context uml.ConnectionPointReference
check _self.entries.forAll[org.eclipse.uml2.uml.Pseudostate s|s.kind == org.eclipse.uml2.uml.PseudostateKind.ENTRY_POINT]
        
// --- --- --- class --- Trigger */

// --- invariant trigger_with_ports 
// --- category ATTR 
// OCL --- If a Trigger specifies one or more ports, the event of the Trigger must be a MessageEvent.
// INV --- port->notEmpty() implies event.oclIsKindOf(MessageEvent)
      
// --- --- --- class --- Port */

// --- invariant port_aggregation 
// --- category ATTR 
// OCL --- Port.aggregation must be composite.
// INV --- aggregation = AggregationKind::composite
      

// --- invariant default_value 
// --- category ATTR 
// OCL --- A defaultValue for port cannot be specified when the type of the Port is an Interface.
// INV --- type.oclIsKindOf(Interface) implies defaultValue->isEmpty()
      

// --- invariant encapsulated_owner 
// --- category ATTR 
// OCL --- All Ports are owned by an EncapsulatedClassifier.
// INV --- owner = encapsulatedClassifier
      
// --- --- --- class --- Transition */

// --- invariant state_is_external 
// --- category ATTR 
// OCL --- A Transition with kind external can source any Vertex except entry points.
// INV --- (kind = TransitionKind::external) implies
// INV ---   not (source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint)
  

// --- invariant join_segment_guards 
// --- category ATTR 
// OCL --- A join segment must not have Guards or Triggers.
// INV --- (target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind = PseudostateKind::join) implies (guard = null and trigger->isEmpty())
      

// --- invariant state_is_internal 
// --- category ATTR 
// OCL --- A Transition with kind internal must have a State as its source, and its source and target must be equal.
// INV --- (kind = TransitionKind::internal) implies
// INV ---     (source.oclIsKindOf (State) and source = target)
      

// --- invariant outgoing_pseudostates 
// --- category ATTR 
// OCL --- Transitions outgoing Pseudostates may not have a Trigger.
// INV --- source.oclIsKindOf(Pseudostate) and (source.oclAsType(Pseudostate).kind <> PseudostateKind::initial) implies trigger->isEmpty()
      

// --- invariant join_segment_state 
// --- category ATTR 
// OCL --- A join segment must always originate from a State.
// INV --- (target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind = PseudostateKind::join) implies (source.oclIsKindOf(State))
      

// --- invariant fork_segment_state 
// --- category ATTR 
// OCL --- A fork segment must always target a State.
// INV --- (source.oclIsKindOf(Pseudostate) and  source.oclAsType(Pseudostate).kind = PseudostateKind::fork) implies (target.oclIsKindOf(State))
      

// --- invariant state_is_local 
// --- category ATTR 
// OCL --- A Transition with kind local must have a composite State or an entry point as its source.
// INV --- (kind = TransitionKind::local) implies
// INV ---     ((source.oclIsKindOf (State) and source.oclAsType(State).isComposite) or
// INV ---     (source.oclIsKindOf (Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint))
      

// --- invariant initial_transition 
// --- category ATTR 
// OCL --- An initial Transition at the topmost level Region of a StateMachine that has no Trigger.
// INV --- (source.oclIsKindOf(Pseudostate) and container.stateMachine->notEmpty()) implies
// INV ---   trigger->isEmpty()
      

// --- invariant fork_segment_guards 
// --- category ATTR 
// OCL --- A fork segment must not have Guards or Triggers.
// INV --- (source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::fork) implies (guard = null and trigger->isEmpty())
      
// --- --- --- class --- OperationTemplateParameter */

// --- invariant match_default_signature
// --- category IGN_COMPLEX
// OCL --- default->notEmpty() implies (default.oclIsKindOf(Operation) and (let defaultOp : Operation = default.oclAsType(Operation) in 
// INV ---     defaultOp.ownedParameter->size() = parameteredElement.ownedParameter->size() and
// INV ---     Sequence{1.. defaultOp.ownedParameter->size()}->forAll( ix | 
// INV ---         let p1: Parameter = defaultOp.ownedParameter->at(ix), p2 : Parameter = parameteredElement.ownedParameter->at(ix) in
// INV ---           p1.type = p2.type and p1.upper = p2.upper and p1.lower = p2.lower and p1.direction = p2.direction and p1.isOrdered = p2.isOrdered and p1.isUnique = p2.isUnique)))
      
// --- --- --- class --- Enumeration */

// --- invariant immutable 
// --- category INV_FORALL 
// OCL --- 
// INV --- ownedAttribute->forAll(isReadOnly)
invariant immutable (uml.Property p)
context uml.Enumeration
check _self.ownedAttributes.forAll[org.eclipse.uml2.uml.Property p|p.isReadOnly]
      
// --- --- --- class --- InstanceSpecification */

// --- invariant deployment_artifact 
// --- category INV_EXISTS* 
// OCL --- An InstanceSpecification can act as a DeployedArtifact if it represents an instance of an Artifact.
// INV --- deploymentForArtifact->notEmpty() implies classifier->exists(oclIsKindOf(Artifact))
invariant deployment_artifact (uml.Classifier c)
context uml.InstanceSpecification
check _self.classifiers.exists[org.eclipse.uml2.uml.Classifier c|c.oclIsKindOf(org.eclipse.uml2.uml.Artifact)]
      

// --- invariant structural_feature
// --- category INV_FORALL
// OCL --- No more than one slot in an InstanceSpecification may have the same definingFeature.
// INV --- classifier->forAll(c | (c.allSlottableFeatures()->forAll(f | slot->select(s | s.definingFeature = f)->size() <= 1)))
invariant structural_feature (uml.Classifier c)
context uml.InstanceSpecification
check _self.classifiers.forAll[org.eclipse.uml2.uml.Classifier c|
	c.allSlottableFeatures.forAll[f|
		_self.slots.select[s|s.definingFeature == f].size <= 1
	]
]

// --- invariant defining_feature
// --- category INV_FORALL
// OCL --- The definingFeature of each slot is a StructuralFeature related to a classifier of the InstanceSpecification, including direct attributes, inherited attributes, private attributes in generalizations, and memberEnds of Associations, but excluding redefined StructuralFeatures.
// INV --- slot->forAll(s | classifier->exists (c | c.allSlottableFeatures()->includes (s.definingFeature)))
invariant defining_feature (uml.Slot s)
context uml.InstanceSpecification
check _self.slots.forAll[org.eclipse.uml2.uml.Slot s|
	_self.classifiers.exists[c|
		c.allSlottableFeatures.includes(s.definingFeature)
	]
]

// --- invariant deployment_target
// --- category IGN_ILLEGAL
// OCL --- An InstanceSpecification can act as a DeploymentTarget if it represents an instance of a Node and functions as a part in the internal structure of an encompassing Node.
// INV --- deployment->notEmpty() implies classifier->exists(node | node.oclIsKindOf(Node) and Node.allInstances()->exists(n | n.part->exists(p | p.type = node)))
      
// --- --- --- class --- ElementImport */

// --- invariant imported_element_is_public 
// --- category ATTR 
// OCL --- An importedElement has either public visibility or no visibility at all.
// INV --- importedElement.visibility <> null implies importedElement.visibility = VisibilityKind::public
      

// --- invariant visibility_public_or_private 
// --- category ATTR 
// OCL --- The visibility of an ElementImport is either public or private.
// INV --- visibility = VisibilityKind::public or visibility = VisibilityKind::private
      
// --- --- --- class --- PackageImport */

// --- invariant public_or_private 
// --- category ATTR 
// OCL --- The visibility of a PackageImport is either public or private.
// INV --- visibility = VisibilityKind::public or visibility = VisibilityKind::private
      
// --- --- --- class --- Extension

// --- invariant non_owned_end 
// --- category ATTR 
// OCL --- The non-owned end of an Extension is typed by a Class.
// INV --- metaclassEnd()->notEmpty() and metaclassEnd().type.oclIsKindOf(Class)
      

// --- invariant is_binary
// --- category SIZE
// OCL --- An Extension is binary, i.e., it has only two memberEnds.
// INV --- memberEnd->size() = 2
      
// --- --- --- class --- ExtensionEnd */

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of ExtensionEnd is 0..1 or 1.
// INV --- (lowerBound() = 0 or lowerBound() = 1) and upperBound() = 1
      

// --- invariant aggregation 
// --- category ATTR 
// OCL --- The aggregation of an ExtensionEnd is composite.
// INV --- self.aggregation = AggregationKind::composite
      
// --- --- --- class --- StringExpression */

// --- invariant operands 
// --- category INV_FORALL 
// OCL --- All the operands of a StringExpression must be LiteralStrings
// INV --- operand->forAll (oclIsKindOf (LiteralString))
invariant operands (uml.ValueSpecification e)
context uml.StringExpression
check _self.operands.forAll[org.eclipse.uml2.uml.ValueSpecification e|e.oclIsKindOf(org.eclipse.uml2.uml.LiteralString)]
      

// --- invariant subexpressions 
// --- category ATTR 
// OCL --- If a StringExpression has sub-expressions, it cannot have operands and vice versa (this avoids the problem of having to define a collating sequence between operands and subexpressions).
// INV --- if subExpression->notEmpty() then operand->isEmpty() else operand->notEmpty() endif
      
// --- --- --- class --- CollaborationUse */

// --- invariant client_elements
// --- category IGN_COMPLEX
// OCL --- All the client elements of a roleBinding are in one Classifier and all supplier elements of a roleBinding are in one Collaboration.
// INV --- roleBinding->collect(client)->forAll(ne1, ne2 |
// INV ---   ne1.oclIsKindOf(ConnectableElement) and ne2.oclIsKindOf(ConnectableElement) and
// INV ---     let ce1 : ConnectableElement = ne1.oclAsType(ConnectableElement), ce2 : ConnectableElement = ne2.oclAsType(ConnectableElement) in
// INV ---       ce1.structuredClassifier = ce2.structuredClassifier)
// INV --- and
// INV ---   roleBinding->collect(supplier)->forAll(ne1, ne2 |
// INV ---   ne1.oclIsKindOf(ConnectableElement) and ne2.oclIsKindOf(ConnectableElement) and
// INV ---     let ce1 : ConnectableElement = ne1.oclAsType(ConnectableElement), ce2 : ConnectableElement = ne2.oclAsType(ConnectableElement) in
// INV ---       ce1.collaboration = ce2.collaboration)
      

// --- invariant every_role
// --- category INV_FORALL
// OCL --- Every collaborationRole in the Collaboration is bound within the CollaborationUse.
// INV --- type.collaborationRole->forAll(role | roleBinding->exists(rb | rb.supplier->includes(role)))
invariant every_role (uml.ConnectableElement r)
context uml.CollaborationUse
check _self.type.collaborationRoles.forAll[org.eclipse.uml2.uml.ConnectableElement r|
	_self.roleBindings.exists[rb|rb.suppliers.includes(r)]
]
      

// --- invariant connectors
// --- category IGN_COMPLEX
// OCL --- Connectors in a Collaboration typing a CollaborationUse must have corresponding Connectors between elements bound in the  Classifier, and these corresponding Connectors must have the same or more general type than the Collaboration Connectors.
// INV --- type.ownedConnector->forAll(connector |
// INV ---   let rolesConnectedInCollab : Set(ConnectableElement) = connector.end.role->asSet(),
// INV ---         relevantBindings : Set(Dependency) = roleBinding->select(rb | rb.supplier->intersection(rolesConnectedInCollab)->notEmpty()),
// INV ---         boundRoles : Set(ConnectableElement) = relevantBindings->collect(client.oclAsType(ConnectableElement))->asSet(),
// INV ---         contextClassifier : StructuredClassifier = boundRoles->any(true).structuredClassifier->any(true) in
// INV ---           contextClassifier.ownedConnector->exists( correspondingConnector | 
// INV ---               correspondingConnector.end.role->forAll( role | boundRoles->includes(role) )
// INV ---               and (connector.type->notEmpty() and correspondingConnector.type->notEmpty()) implies connector.type->forAll(conformsTo(correspondingConnector.type)) )
// INV --- )
      
// --- --- --- class --- Connector */

// --- invariant types
// --- category IGN_COMPLEX
// OCL --- The types of the ConnectableElements that the ends of a Connector are attached to must conform to the types of the ends of the Association that types the Connector, if any.
// INV --- type<>null implies 
// INV ---   let noOfEnds : Integer = end->size() in 
// INV ---   (type.memberEnd->size() = noOfEnds) and Sequence{1..noOfEnds}->forAll(i | end->at(i).role.type.conformsTo(type.memberEnd->at(i).type))
      

// --- invariant roles
// --- category IGN_COMPLEX
// OCL --- The ConnectableElements attached as roles to each ConnectorEnd owned by a Connector must be owned or inherited roles of the Classifier that owned the Connector, or they must be Ports of such roles.
// INV --- structuredClassifier <> null
// INV --- and
// INV ---   end->forAll( e | structuredClassifier.allRoles()->includes(e.role)
// INV --- or
// INV ---   e.role.oclIsKindOf(Port) and structuredClassifier.allRoles()->includes(e.partWithPort))
      
// --- --- --- class --- GeneralizationSet */

// --- invariant generalization_same_classifier
// --- category SIZE
// OCL --- Every Generalization associated with a particular GeneralizationSet must have the same general Classifier.
// INV --- generalization->collect(general)->asSet()->size() <= 1
      

// --- invariant maps_to_generalization_set 
// --- category INV_FORALL 
// OCL --- The Classifier that maps to a GeneralizationSet may neither be a specific nor a general Classifier in any of the Generalization relationships defined for that GeneralizationSet. In other words, a power type may not be an instance of itself nor may its instances be its subclasses.
// INV --- powertype <> null implies generalization->forAll( gen | 
// INV ---     not (gen.general = powertype) and not gen.general.allParents()->includes(powertype) and not (gen.specific = powertype) and not powertype.allParents()->includes(gen.specific)
// INV ---   )
invariant maps_to_generalization_set (uml.Generalization g)
context uml.GeneralizationSet
check _self.generalizations.forAll[org.eclipse.uml2.uml.Generalization g|
	g.general != _self.powertype && !g.general.allParents.includes(_self.powertype) && g.specific != _self.powertype && !_self.powertype.allParents.includes(g.specific)
]
      
// --- --- --- class --- RedefinableTemplateSignature /*

// --- invariant redefines_parents
// --- category IGN_ILLEGAL
// OCL --- If any of the parent Classifiers are a template, then the extendedSignature must include the signature of that Classifier.
// INV --- classifier.allParents()->forAll(c | c.ownedTemplateSignature->notEmpty() implies self->closure(extendedSignature)->includes(c.ownedTemplateSignature))
      
// --- --- --- class --- UseCase /*

// --- invariant binary_associations
// --- category IGN_ILLEGAL
// OCL --- UseCases can only be involved in binary Associations.
// INV --- Association.allInstances()->forAll(a | a.memberEnd.type->includes(self) implies a.memberEnd->size() = 2)
      

// --- invariant no_association_to_use_case
// --- category IGN_ILLEGAL
// OCL --- UseCases cannot have Associations to UseCases specifying the same subject.
// INV --- Association.allInstances()->forAll(a | a.memberEnd.type->includes(self) implies 
// INV ---    (
// INV ---    let usecases: Set(UseCase) = a.memberEnd.type->select(oclIsKindOf(UseCase))->collect(oclAsType(UseCase))->asSet() in
// INV ---    usecases->size() > 1 implies usecases->collect(subject)->size() > 1
// INV ---    )
// INV --- )
      

// --- invariant cannot_include_self 
// --- category INV_EXISTS* 
// OCL --- A UseCase cannot include UseCases that directly or indirectly include it.
// INV --- not allIncludedUseCases()->includes(self)
invariant cannot_include_self (uml.UseCase u)
context uml.UseCase
check !_self.allIncludedUseCases.exists[org.eclipse.uml2.uml.UseCase u|u == _self]
      

// --- invariant must_have_name 
// --- category ATTR 
// OCL --- A UseCase must have a name.
// INV --- name -> notEmpty ()
      
// --- --- --- class --- Extend */

// --- invariant extension_points 
// --- category INV_FORALL 
// OCL --- The ExtensionPoints referenced by the Extend relationship must belong to the UseCase that is being extended.
// INV --- extensionLocation->forAll (xp | extendedCase.extensionPoint->includes(xp))
invariant extension_points (uml.ExtensionPoint p)
context uml.Extend
check _self.extensionLocations.forAll[org.eclipse.uml2.uml.ExtensionPoint p|
	_self.extendedCase.extensionPoints.includes(p)
]
      
// --- --- --- class --- ExtensionPoint */

// --- invariant must_have_name 
// --- category ATTR 
// OCL --- An ExtensionPoint must have a name.
// INV --- name->notEmpty ()
      
// --- --- --- class --- ClassifierTemplateParameter */

// --- invariant has_constraining_classifier 
// --- category ATTR 
// OCL --- If allowSubstitutable is true, then there must be a constrainingClassifier.
// INV --- allowSubstitutable implies constrainingClassifier->notEmpty()
      

// --- invariant parametered_element_no_features
// --- category SIZE
// OCL --- The parameteredElement has no direct features, and if constrainedElement is empty it has no generalizations.
// INV --- parameteredElement.feature->isEmpty() and (constrainingClassifier->isEmpty() implies  parameteredElement.allParents()->isEmpty())

// --- invariant matching_abstract
// --- category IGN_ILLEGAL
// OCL --- If the parameteredElement is not abstract, then the Classifier used as an argument shall not be abstract.
// INV --- (not parameteredElement.isAbstract) implies templateParameterSubstitution.actual->forAll(a | not a.oclAsType(Classifier).isAbstract)

// --- invariant actual_is_classifier
// --- category IGN_ILLEGAL
// OCL --- The argument to a ClassifierTemplateParameter is a Classifier.
// INV ---  templateParameterSubstitution.actual->forAll(a | a.oclIsKindOf(Classifier))
      

// --- invariant constraining_classifiers_constrain_args
// --- category IGN_COMPLEX
// OCL --- If there are any constrainingClassifiers, then every argument must be the same as or a specialization of them, or if allowSubstitutable is true, then it can also be substitutable.
// INV --- templateParameterSubstitution.actual->forAll( a |
// INV ---   let arg : Classifier = a.oclAsType(Classifier) in
// INV ---     constrainingClassifier->forAll(
// INV ---       cc |  
// INV ---          arg = cc or arg.conformsTo(cc) or (allowSubstitutable and arg.isSubstitutableFor(cc))
// INV ---       )
// INV --- )
      

// --- invariant constraining_classifiers_constrain_parametered_element
// --- category IGN_COMPLEX
// OCL --- If there are any constrainingClassifiers, then the parameteredElement must be the same as or a specialization of them, or if allowSubstitutable is true, then it can also be substitutable.
// INV --- constrainingClassifier->forAll(
// INV ---      cc |  parameteredElement = cc or parameteredElement.conformsTo(cc) or (allowSubstitutable and parameteredElement.isSubstitutableFor(cc))
// INV --- )
      
// --- --- --- class --- ActivityGroup */

// --- invariant nodes_and_edges 
// --- category INV_FORALL
// OCL --- All containedNodes and containeEdges of an ActivityGroup must be in the same Activity as the group.
// INV --- containedNode->forAll(activity = self.containingActivity()) and 
// INV --- containedEdge->forAll(activity = self.containingActivity())
invariant nodes_and_edges (uml.ActivityNode n, uml.ActivityEdge e)
context uml.ActivityGroup
check _self.containedNodes.forAll[org.eclipse.uml2.uml.ActivityNode n|n.activity == _self.containingActivity] &&
	_self.containedEdges.forAll[org.eclipse.uml2.uml.ActivityEdge e|e.activity == _self.containingActivity]
      

// --- invariant not_contained
// --- category IGN_ILLEGAL
// OCL --- No containedNode or containedEdge of an ActivityGroup may be contained by its subgroups or its superGroups, transitively.
// INV --- subgroup->closure(subgroup).containedNode->excludesAll(containedNode) and
// INV --- superGroup->closure(superGroup).containedNode->excludesAll(containedNode) and 
// INV --- subgroup->closure(subgroup).containedEdge->excludesAll(containedEdge) and 
// INV --- superGroup->closure(superGroup).containedEdge->excludesAll(containedEdge)
      
// --- --- --- class --- ActivityEdge */

// --- invariant source_and_target 
// --- category ATTR 
// OCL --- If an ActivityEdge is directly owned by an Activity, then its source and target must be directly or indirectly contained in the same Activity.
// INV --- activity<>null implies source.containingActivity() = activity and target.containingActivity() = activity
      
// --- --- --- class --- ActivityPartition */

// --- invariant represents_classifier
// --- category IGN_COMPLEX
// OCL --- If a non-external ActivityPartition represents a Classifier and has a superPartition, then the superPartition must represent a Classifier, and the Classifier of the subpartition must be nested (nestedClassifier or ownedBehavior) in the Classifier represented by the superPartition, or be at the contained end of a composition Association with the Classifier represented by the superPartition.
// INV --- (not isExternal and represents.oclIsKindOf(Classifier) and superPartition->notEmpty()) implies
// INV --- (
// INV ---    let representedClassifier : Classifier = represents.oclAsType(Classifier) in
// INV ---      superPartition.represents.oclIsKindOf(Classifier) and
// INV ---       let representedSuperClassifier : Classifier = superPartition.represents.oclAsType(Classifier) in
// INV ---        (representedSuperClassifier.oclIsKindOf(BehavioredClassifier) and representedClassifier.oclIsKindOf(Behavior) and 
// INV ---         representedSuperClassifier.oclAsType(BehavioredClassifier).ownedBehavior->includes(representedClassifier.oclAsType(Behavior))) 
// INV ---        or
// INV ---        (representedSuperClassifier.oclIsKindOf(Class) and  representedSuperClassifier.oclAsType(Class).nestedClassifier->includes(representedClassifier))
// INV ---        or
// INV ---        (Association.allInstances()->exists(a | a.memberEnd->exists(end1 | end1.isComposite and end1.type = representedClassifier and 
// INV ---                                                                       a.memberEnd->exists(end2 | end1<>end2 and end2.type = representedSuperClassifier))))
// INV --- )
      

// --- invariant represents_property_and_is_contained 
// --- category ATTR 
// OCL --- If an ActivityPartition represents a Property and has a superPartition, then the Property must be of a Classifier represented by the superPartition, or of a Classifier that is the type of a Property represented by the superPartition.
// INV --- (represents.oclIsKindOf(Property) and superPartition->notEmpty()) implies
// INV --- (
// INV ---   (superPartition.represents.oclIsKindOf(Classifier) and represents.owner = superPartition.represents) or 
// INV ---   (superPartition.represents.oclIsKindOf(Property) and represents.owner = superPartition.represents.oclAsType(Property).type)
// INV --- )
      

// --- invariant represents_property 
// --- category INV_SELECT_FORALL 
// OCL --- If an ActivityPartition represents a Property and has a superPartition representing a Classifier, then all the other non-external subpartitions of the superPartition must represent Properties directly owned by the same Classifier.
// INV --- (represents.oclIsKindOf(Property) and superPartition->notEmpty() and superPartition.represents.oclIsKindOf(Classifier)) implies
// INV --- (
// INV ---   let representedClassifier : Classifier = superPartition.represents.oclAsType(Classifier)
// INV ---   in
// INV ---     superPartition.subpartition->reject(isExternal)->forAll(p | 
// INV ---        p.represents.oclIsKindOf(Property) and p.owner=representedClassifier)
// INV --- )
invariant represents_property (uml.ActivityPartition sub, uml.ActivityPartition p)
context uml.ActivityPartition
check _self.superPartition.subpartitions.select[org.eclipse.uml2.uml.ActivityPartition sub|!sub.isExternal]
	.forAll[org.eclipse.uml2.uml.ActivityPartition p|p.represents.oclIsKindOf(org.eclipse.uml2.uml.Property)
		&& p.owner == _self.superPartition.represents
	]
      

// --- invariant dimension_not_contained 
// --- category ATTR 
// OCL --- An ActvivityPartition with isDimension = true may not be contained by another ActivityPartition.
// INV --- isDimension implies superPartition->isEmpty()
      
// --- --- --- class --- InterruptibleActivityRegion

// --- invariant interrupting_edges 
// --- category INV_FORALL 
// OCL --- The interruptingEdges of an InterruptibleActivityRegion must have their source in the region and their target outside the region, but within the same Activity containing the region.
// INV --- interruptingEdge->forAll(edge | 
// INV ---   node->includes(edge.source) and node->excludes(edge.target) and edge.target.containingActivity() = inActivity)
invariant interrupting_edges (uml.ActivityEdge edge)
context uml.InterruptibleActivityRegion
check _self.interruptingEdges.forAll[org.eclipse.uml2.uml.ActivityEdge edge|
	_self.nodes.includes(edge.source) && _self.nodes.includes(edge.target) && edge.target.containingActivity == _self.inActivity
]
      
// --- --- --- class --- StructuredActivityNode */

// --- invariant output_pin_edges
// --- category IGN_COMPLEX
// OCL --- The outgoing ActivityEdges of the OutputPins of a StructuredActivityNode must have targets that are not within the StructuredActivityNode.
// INV --- output.outgoing.target->excludesAll(allOwnedNodes()-input)
      

// --- invariant edges
// --- category IGN_COMPLEX
// OCL --- The edges of a StructuredActivityNode are all the ActivityEdges with source and target ActivityNodes contained directly or indirectly within the StructuredActivityNode and at least one of the source or target not contained in any more deeply nested StructuredActivityNode.
// INV --- edge=self.sourceNodes().outgoing->intersection(self.allOwnedNodes().incoming)->
// INV ---   union(self.targetNodes().incoming->intersection(self.allOwnedNodes().outgoing))->asSet()
      

// --- invariant input_pin_edges
// --- category IGN_COMPLEX
// OCL --- The incoming ActivityEdges of an InputPin of a StructuredActivityNode must have sources that are not within the StructuredActivityNode.
// INV --- input.incoming.source->excludesAll(allOwnedNodes()-output)
      
// --- --- --- class --- ExceptionHandler */

// --- invariant handler_body_edges 
// --- category ATTR 
// OCL --- The handlerBody has no incoming or outgoing ActivityEdges and the exceptionInput has no incoming ActivityEdges.
// INV --- handlerBody.incoming->isEmpty() and handlerBody.outgoing->isEmpty() and exceptionInput.incoming->isEmpty()
      

// --- invariant output_pins
// --- category IGN_COMPLEX
// OCL --- If the protectedNode is an Action with OutputPins, then the handlerBody must also be an Action with the same number of OutputPins, which are compatible in type, ordering, and multiplicity to those of the protectedNode.
// INV --- (protectedNode.oclIsKindOf(Action) and protectedNode.oclAsType(Action).output->notEmpty()) implies
// INV --- (
// INV ---   handlerBody.oclIsKindOf(Action) and 
// INV ---   let protectedNodeOutput : OrderedSet(OutputPin) = protectedNode.oclAsType(Action).output,
// INV ---         handlerBodyOutput : OrderedSet(OutputPin) =  handlerBody.oclAsType(Action).output in
// INV ---     protectedNodeOutput->size() = handlerBodyOutput->size() and
// INV ---     Sequence{1..protectedNodeOutput->size()}->forAll(i |
// INV ---       handlerBodyOutput->at(i).type.conformsTo(protectedNodeOutput->at(i).type) and
// INV ---       handlerBodyOutput->at(i).isOrdered=protectedNodeOutput->at(i).isOrdered and
// INV ---       handlerBodyOutput->at(i).compatibleWith(protectedNodeOutput->at(i)))
// INV --- )
      

// --- invariant one_input
// --- category SIZE
// OCL --- The handlerBody is an Action with one InputPin, and that InputPin is the same as the exceptionInput.
// INV --- handlerBody.oclIsKindOf(Action) and
// INV --- let inputs: OrderedSet(InputPin) = handlerBody.oclAsType(Action).input in
// INV --- inputs->size()=1 and inputs->first()=exceptionInput
      

// --- invariant edge_source_target
// --- category INV_MAP_FORALL
// OCL --- An ActivityEdge that has a source within the handlerBody of an ExceptionHandler must have its target in the handlerBody also, and vice versa.
// INV --- let nodes:Set(ActivityNode) = handlerBody.oclAsType(Action).allOwnedNodes() in
// INV --- nodes.outgoing->forAll(nodes->includes(target)) and
// INV --- nodes.incoming->forAll(nodes->includes(source))
invariant edge_source_target
context uml.ExceptionHandler
check {
	val nodes = _self.handlerBody.oclAsType(org.eclipse.uml2.uml.Action).allOwnedNodes
	nodes.map[n|n.outgoings].flatten.forAll[org.eclipse.uml2.uml.ActivityEdge o|nodes.includes(o.target)] &&
	nodes.map[n|n.incomings].flatten.forAll[org.eclipse.uml2.uml.ActivityEdge i|nodes.includes(i.source)]
}
      

// --- invariant handler_body_owner 
// --- category ATTR 
// OCL --- The handlerBody must have the same owner as the protectedNode.
// INV --- handlerBody.owner=protectedNode.owner
      

// --- invariant exception_input_type
// --- category INV_FORALL
// OCL --- The exceptionInput must either have no type or every exceptionType must conform to the exceptionInput type.
// INV --- exceptionInput.type=null or 
// INV --- exceptionType->forAll(conformsTo(exceptionInput.type.oclAsType(Classifier)))
invariant exception_input_type (uml.Classifier t)
context uml.ExceptionHandler
check _self.exceptionInput.type == null || 
	_self.exceptionTypes.forAll[org.eclipse.uml2.uml.Classifier t|
		t.conformsTo(_self.exceptionInput.type.oclAsType(org.eclipse.uml2.uml.Classifier))
	]
      
// --- --- --- class --- ObjectNode /*

// --- invariant input_output_parameter
// --- category IGN_COMPLEX
// OCL --- A selection Behavior has one input Parameter and one output Parameter. The input Parameter must have the same type as  or a supertype of the type of ObjectNode, be non-unique, and have multiplicity 0..*. The output Parameter must be the same or a subtype of the type of ObjectNode. The Behavior cannot have side effects.
// INV --- selection<>null implies
// INV ---   selection.inputParameters()->size()=1 and
// INV ---   selection.inputParameters()->forAll(p | not p.isUnique and p.is(0,*) and self.type.conformsTo(p.type)) and
// INV ---   selection.outputParameters()->size()=1 and
// INV ---     selection.inputParameters()->forAll(p | self.type.conformsTo(p.type))
      

// --- invariant selection_behavior 
// --- category ATTR 
// OCL --- If an ObjectNode has a selection Behavior, then the ordering of the  node is ordered, and vice versa.
// INV --- (selection<>null) = (ordering=ObjectNodeOrderingKind::ordered)
      

// --- invariant object_flow_edges 
// --- category INV_FORALL 
// OCL --- If isControlType=false, the ActivityEdges incoming to or outgoing from an ObjectNode must all be ObjectFlows.
// INV --- (not isControlType) implies incoming->union(outgoing)->forAll(oclIsKindOf(ObjectFlow))
invariant object_flow_edges (uml.ActivityEdge e)
context uml.ObjectNode
check _self.isControlType || _self.incomings.union(_self.outgoings).forAll[org.eclipse.uml2.uml.ActivityEdge e|e.oclIsKindOf(org.eclipse.uml2.uml.ObjectFlow)]
      
// --- --- --- class --- InputPin */

// --- invariant outgoing_edges_structured_only 
// --- category IGN_COMPLEX
// OCL --- An InputPin may have outgoing ActivityEdges only when it is owned by a StructuredActivityNode, and these edges must target a node contained (directly or indirectly) in the owning StructuredActivityNode.
// INV --- outgoing->notEmpty() implies
// INV ---   action<>null and
// INV ---   action.oclIsKindOf(StructuredActivityNode) and
// INV ---   action.oclAsType(StructuredActivityNode).allOwnedNodes()->includesAll(outgoing.target)
      
// --- --- --- class --- Pin */
	
// --- invariant control_pins 
// --- category ATTR 
// OCL --- A control Pin has a control type.
// INV --- isControl implies isControlType
      

// --- invariant not_unique 
// --- category ATTR
// OCL --- Pin multiplicity is not unique.
// INV --- not isUnique
      
// --- --- --- class --- OutputPin */

// --- invariant incoming_edges_structured_only
// --- category IGN_COMPLEX
// OCL --- An OutputPin may have incoming ActivityEdges only when it is owned by a StructuredActivityNode, and these edges must have sources contained (directly or indirectly) in the owning StructuredActivityNode.
// INV --- incoming->notEmpty() implies
// INV ---   action<>null and
// INV ---   action.oclIsKindOf(StructuredActivityNode) and
// INV ---   action.oclAsType(StructuredActivityNode).allOwnedNodes()->includesAll(incoming.source)
      
// --- --- --- class --- ValueSpecificationAction */

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the result OutputPin is 1..1
// INV --- result.is(1,1)
      

// --- invariant compatible_type 
// --- category ATTR 
// OCL --- The type of the value ValueSpecification must conform to the type of the result OutputPin.
// INV --- value.type.conformsTo(result.type)
      
// --- --- --- class --- VariableAction */

// --- invariant scope_of_variable 
// --- category ATTR 
// OCL --- The VariableAction must be in the scope of the variable.
// INV --- variable.isAccessibleBy(self)

// --- --- --- class --- WriteLinkAction */

// --- invariant allow_access
// --- category INV_EXISTS
// OCL --- The visibility of at least one end must allow access from the  Classifier of the WriteLinkAction.
// INV --- endData.end->exists(end |
// INV ---   end.type=_'' or
// INV ---   end.visibility=VisibilityKind::public or 
// INV ---   end.visibility=VisibilityKind::protected and
// INV ---   endData.end->exists(other | 
// INV ---     other<>end and _''.conformsTo(other.type.oclAsType(Classifier))))
invariant allow_access (uml.Property p)
context uml.WriteLinkAction
check _self.endData.map[ed|ed.end].exists[org.eclipse.uml2.uml.Property  p|
	p.visibility == org.eclipse.uml2.uml.VisibilityKind.PUBLIC || p.visibility == org.eclipse.uml2.uml.VisibilityKind.PROTECTED
		|| _self.endData.map[ed2|ed2.end].exists[o| o != p && p.type.conformsTo(o.type.oclAsType(org.eclipse.uml2.uml.Classifier))]
]

// --- --- --- class --- LinkAction */

// --- invariant same_pins 
// --- category ATTR 
// OCL --- The inputValue InputPins is the same as the union of all the InputPins referenced by the endData.
// INV --- inputValue->asBag()=endData.allPins()
      

// --- invariant same_association 
// --- category ATTR 
// OCL --- The ends of the endData must all be from the same Association and include all and only the memberEnds of that association.
// INV --- endData.end = self.association().memberEnd->asBag()
      

// --- invariant not_static 
// --- category INV_FORALL 
// OCL --- The ends of the endData must not be static.
// INV --- endData->forAll(not end.isStatic)
invariant not_static (uml.LinkEndData e)
context uml.LinkAction
check _self.endData.forAll[org.eclipse.uml2.uml.LinkEndData e|!e.end.isStatic]
      
// --- --- --- class --- LinkEndData */

// --- invariant same_type 
// --- category ATTR 
// OCL --- The type of the value InputPin conforms to the type of the Association end.
// INV --- value<>null implies value.type.conformsTo(end.type)
      

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the value InputPin must be 1..1.
// INV --- value<>null implies value.is(1,1)
      

// --- invariant end_object_input_pin 
// --- category INV_EXISTS* 
// OCL --- The value InputPin is not also the qualifier value InputPin.
// INV --- value->excludesAll(qualifier.value)
invariant end_object_input_pin (uml.QualifierValue e)
context uml.LinkEndData
check !_self.qualifiers.exists[org.eclipse.uml2.uml.QualifierValue e|e.value == _self.value]
      

// --- invariant property_is_association_end 
// --- category ATTR 
// OCL --- The Property must be an Association memberEnd.
// INV --- end.association <> null
      

// --- invariant qualifiers 
// --- category INV_FORALL* 
// OCL --- The qualifiers must be qualifiers of the Association end.
// INV --- end.qualifier->includesAll(qualifier.qualifier)
invariant qualifiers (uml.QualifierValue e)
context uml.LinkEndData
check _self.qualifiers.forAll[org.eclipse.uml2.uml.QualifierValue e|_self.end.qualifiers.includes(e.qualifier)]
      
// --- --- --- class --- QualifierValue */

// --- invariant multiplicity_of_qualifier 
// --- category ATTR 
// OCL --- The multiplicity of the value InputPin is 1..1.
// INV --- value.is(1,1)
      

// --- invariant type_of_qualifier 
// --- category ATTR 
// OCL --- The type of the value InputPin conforms to the type of the qualifier Property.
// INV --- value.type.conformsTo(qualifier.type)
      

// --- invariant qualifier_attribute
// --- category IGN_COMPLEX
// OCL --- The qualifier must be a qualifier of the Association end of the linkEndData that owns this QualifierValue.
// INV --- linkEndData.end.qualifier->includes(qualifier)

// --- --- --- class --- WriteStructuralFeatureAction */

// --- invariant multiplicity_of_result 
// --- category ATTR 
// OCL --- The multiplicity of the result OutputPin must be 1..1.
// INV --- result <> null implies result.is(1,1)
      

// --- invariant type_of_value 
// --- category ATTR 
// OCL --- The type of the value InputPin must conform to the type of the structuralFeature.
// INV --- value <> null implies value.type.conformsTo(structuralFeature.type)
      

// --- invariant multiplicity_of_value 
// --- category ATTR 
// OCL --- The multiplicity of the value InputPin is 1..1.
// INV --- value<>null implies value.is(1,1)
      

// --- invariant type_of_result 
// --- category ATTR 
// OCL --- The type of the result OutputPin is the same as the type of the inherited  InputPin.
// INV --- result <> null implies result.type = .type

// --- --- --- class --- StructuralFeatureAction */

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the  InputPin must be 1..1.
// INV --- .is(1,1)
      

// --- invariant object_type 
// --- category ATTR 
// OCL --- The structuralFeature must either be an owned or inherited feature of the type of the  InputPin, or it must be an owned end of a binary Association whose opposite end had as a type to which the type of the  InputPin conforms.
// INV --- .type.oclAsType(Classifier).allFeatures()->includes(structuralFeature) or
// INV ---   .type.conformsTo(structuralFeature.oclAsType(Property).opposite.type)
      

// --- invariant visibility 
// --- category ATTR 
// OCL --- The visibility of the structuralFeature must allow access from the  performing the ReadStructuralFeatureAction.
// INV --- structuralFeature.visibility = VisibilityKind::public or
// INV --- _''.allFeatures()->includes(structuralFeature) or
// INV --- structuralFeature.visibility=VisibilityKind::protected and
// INV --- _''.conformsTo(structuralFeature.oclAsType(Property).opposite.type.oclAsType(Classifier))
      

// --- invariant not_static 
// --- category ATTR 
// OCL --- The structuralFeature must not be static.
// INV --- not structuralFeature.isStatic
      

// --- invariant one_featuring_classifier
// --- category SIZE
// OCL --- The structuralFeature must have exactly one featuringClassifier.
// INV --- structuralFeature.featuringClassifier->size() = 1
      
// --- --- --- class --- WriteVariableAction */

// --- invariant value_type 
// --- category ATTR 
// OCL --- The type of the value InputPin must conform to the type of the variable.
// INV --- value <> null implies value.type.conformsTo(variable.type)
      

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the value InputPin is 1..1.
// INV --- value<>null implies value.is(1,1)
      
// --- --- --- class --- AcceptCallAction */

// --- invariant result_pins
// --- category IGN_COMPLEX
// OCL --- The number of result OutputPins must be the same as the number of input (in and inout) ownedParameters of the Operation specified by the trigger Event. The type, ordering and multiplicity of each result OutputPin must be consistent with the corresponding input Parameter.
// INV --- let parameter: OrderedSet(Parameter) = trigger.event->asSequence()->first().oclAsType(CallEvent).operation.inputParameters() in
// INV --- result->size() = parameter->size() and
// INV --- Sequence{1..result->size()}->forAll(i | 
// INV ---   parameter->at(i).type.conformsTo(result->at(i).type) and 
// INV ---   parameter->at(i).isOrdered = result->at(i).isOrdered and
// INV ---   parameter->at(i).compatibleWith(result->at(i)))
      

// --- invariant trigger_call_event
// --- category SIZE
// OCL --- The action must have exactly one trigger, which must be for a CallEvent.
// INV --- trigger->size()=1 and
// INV --- trigger->asSequence()->first().event.oclIsKindOf(CallEvent)
      

// --- invariant unmarshall 
// --- category ATTR 
// OCL --- isUnmrashall must be true for an AcceptCallAction.
// INV --- isUnmarshall = true
      
// --- --- --- class --- AcceptEventAction */

// --- invariant one_output_pin
// --- category SIZE
// OCL --- If isUnmarshall=false and any of the triggers are for SignalEvents or TimeEvents, there must be exactly one result OutputPin with multiplicity 1..1.
// INV --- not isUnmarshall and trigger->exists(event.oclIsKindOf(SignalEvent) or event.oclIsKindOf(TimeEvent)) implies 
// INV ---   output->size() = 1 and output->first().is(1,1)
      

// --- invariant no_input_pins
// --- category SIZE
// OCL --- AcceptEventActions may have no input pins.
// INV --- input->size() = 0
      

// --- invariant no_output_pins
// --- category SIZE
// OCL --- There are no OutputPins if the trigger events are only ChangeEvents and/or CallEvents when this action is an instance of AcceptEventAction and not an instance of a descendant of AcceptEventAction (such as AcceptCallAction).
// INV --- (self.oclIsTypeOf(AcceptEventAction) and
// INV ---    (trigger->forAll(event.oclIsKindOf(ChangeEvent) or  
// INV ---                              event.oclIsKindOf(CallEvent))))
// INV --- implies output->size() = 0
      

// --- invariant unmarshall_signal_events
// --- category IGN_COMPLEX
// OCL --- If isUnmarshall is true (and this is not an AcceptCallAction), there must be exactly one trigger, which is for a SignalEvent. The number of result output pins must be the same as the number of attributes of the signal. The type and ordering of each result output pin must be the same as the corresponding attribute of the signal. The multiplicity of each result output pin must be compatible with the multiplicity of the corresponding attribute.
// INV --- isUnmarshall and self.oclIsTypeOf(AcceptEventAction) implies
// INV ---   trigger->size()=1 and
// INV ---   trigger->asSequence()->first().event.oclIsKindOf(SignalEvent) and
// INV ---   let attribute: OrderedSet(Property) = trigger->asSequence()->first().event.oclAsType(SignalEvent).signal.allAttributes() in
// INV ---   attribute->size()>0 and result->size() = attribute->size() and
// INV ---   Sequence{1..result->size()}->forAll(i | 
// INV ---     result->at(i).type = attribute->at(i).type and 
// INV ---     result->at(i).isOrdered = attribute->at(i).isOrdered and
// INV ---     result->at(i).includesMultiplicity(attribute->at(i)))
      

// --- invariant conforming_type
// --- category IGN_COMPLEX
// OCL --- If isUnmarshall=false and all the triggers are for SignalEvents, then the type of the single result OutputPin must either be null or all the signals must conform to it.
// INV --- not isUnmarshall implies 
// INV ---   result->isEmpty() or
// INV ---   let type: Type = result->first().type in
// INV ---   type=null or 
// INV ---     (trigger->forAll(event.oclIsKindOf(SignalEvent)) and 
// INV ---      trigger.event.oclAsType(SignalEvent).signal->forAll(s | s.conformsTo(type)))
      
// --- --- --- class --- ActionInputPin */

// --- invariant input_pin 
// --- category INV_FORALL 
// OCL --- The fromAction of an ActionInputPin must only have ActionInputPins as InputPins.
// INV --- fromAction.input->forAll(oclIsKindOf(ActionInputPin))
invariant input_pin (uml.InputPin pin)
context uml.ActionInputPin
check _self.fromAction.inputs.forAll[org.eclipse.uml2.uml.InputPin pin|pin.oclIsKindOf(org.eclipse.uml2.uml.ActionInputPin)]
      

// --- invariant one_output_pin
// --- category SIZE
// OCL --- The fromAction of an ActionInputPin must have exactly one OutputPin.
// INV --- fromAction.output->size() = 1
      

// --- invariant no_control_or_object_flow 
// --- category ATTR 
// OCL --- The fromAction of an ActionInputPin cannot have ActivityEdges coming into or out of it or its Pins.
// INV --- fromAction.incoming->union(outgoing)->isEmpty() and
// INV --- fromAction.input.incoming->isEmpty() and
// INV --- fromAction.output.outgoing->isEmpty()
      
// --- --- --- class --- AddStructuralFeatureValueAction */

// --- invariant required_value 
// --- category ATTR 
// OCL --- A value InputPin is required.
// INV --- value<>null
      

// --- invariant insertAt_pin
// --- category IGN_COMPLEX
// OCL --- AddStructuralFeatureActions adding a value to ordered StructuralFeatures must have a single InputPin for the insertion point with type UnlimitedNatural and multiplicity of 1..1 if isReplaceAll=false, and must have no Input Pin for the insertion point when the StructuralFeature is unordered.
// INV --- if not structuralFeature.isOrdered then insertAt = null
// INV --- else 
// INV ---   not isReplaceAll implies
// INV ---     insertAt<>null and 
// INV ---     insertAt->forAll(type=UnlimitedNatural and is(1,1.oclAsType(UnlimitedNatural)))
// INV --- endif
      
// --- --- --- class --- AddVariableValueAction */

// --- invariant required_value 
// --- category ATTR 
// OCL --- A value InputPin is required.
// INV --- value <> null
      

// --- invariant insertAt_pin 
// --- category ATTR
// OCL --- AddVariableValueActions for ordered Variables must have a single InputPin for the insertion point with type UnlimtedNatural and multiplicity of 1..1 if isReplaceAll=false, otherwise the Action has no InputPin for the insertion point.
// INV --- if not variable.isOrdered then insertAt = null
// INV --- else 
// INV ---   not isReplaceAll implies
// INV ---     insertAt<>null and 
// INV ---     insertAt->forAll(type=UnlimitedNatural and is(1,1.oclAsType(UnlimitedNatural)))
// INV --- endif
      
// --- --- --- class --- BroadcastSignalAction */

// --- invariant number_of_arguments 
// --- category SIZE
// OCL --- The number of argument InputPins must be the same as the number of attributes in the signal.
// INV --- argument->size() = signal.allAttributes()->size()
      

// --- invariant type_ordering_multiplicity
// --- category IGN_COMPLEX
// OCL --- The type, ordering, and multiplicity of an argument InputPin must be the same as the corresponding attribute of the signal.
// INV --- let attribute: OrderedSet(Property) = signal.allAttributes() in
// INV --- Sequence{1..argument->size()}->forAll(i | 
// INV ---   argument->at(i).type.conformsTo(attribute->at(i).type) and 
// INV ---   argument->at(i).isOrdered = attribute->at(i).isOrdered and
// INV ---   argument->at(i).compatibleWith(attribute->at(i)))
      

// --- invariant no_onport 
// --- category ATTR 
// OCL --- A BroadcaseSignalAction may not specify onPort.
// INV --- onPort=null
      
// --- --- --- class --- CallAction */

// --- invariant argument_pins
// --- category IGN_COMPLEX
// OCL --- The number of argument InputPins must be the same as the number of input (in and inout) ownedParameters of the called Behavior or Operation. The type, ordering and multiplicity of each argument InputPin must be consistent with the corresponding input Parameter.
// INV --- let parameter: OrderedSet(Parameter) = self.inputParameters() in
// INV --- argument->size() = parameter->size() and
// INV --- Sequence{1..argument->size()}->forAll(i | 
// INV ---   argument->at(i).type.conformsTo(parameter->at(i).type) and 
// INV ---   argument->at(i).isOrdered = parameter->at(i).isOrdered and
// INV ---   argument->at(i).compatibleWith(parameter->at(i)))
      

// --- invariant result_pins
// --- category IGN_COMPLEX
// OCL --- The number of result OutputPins must be the same as the number of output (inout, out and return) ownedParameters of the called Behavior or Operation. The type, ordering and multiplicity of each result OutputPin must be consistent with the corresponding input Parameter.
// INV --- let parameter: OrderedSet(Parameter) = self.outputParameters() in
// INV --- result->size() = parameter->size() and
// INV --- Sequence{1..result->size()}->forAll(i | 
// INV ---   parameter->at(i).type.conformsTo(result->at(i).type) and 
// INV ---   parameter->at(i).isOrdered = result->at(i).isOrdered and
// INV ---   parameter->at(i).compatibleWith(result->at(i)))
      

// --- invariant synchronous_call 
// --- category ATTR 
// OCL --- Only synchronous CallActions can have result OutputPins.
// INV --- result->notEmpty() implies isSynchronous
      
// --- --- --- class --- CallBehaviorAction */

// --- invariant no_onport 
// --- category ATTR 
// OCL --- A CallBehaviorAction may not specify onPort.
// INV --- onPort=null
      
// --- --- --- class --- CallOperationAction */

// --- invariant type_target_pin 
// --- category IGN_COMPLEX
// OCL --- If onPort has no value, the operation must be an owned or inherited feature of the type of the target InputPin, otherwise the Port given by onPort must be an owned or inherited feature of the type of the target InputPin, and the Port must have a required or provided Interface with the operation as an owned or inherited feature.
// INV --- if onPort=null then  target.type.oclAsType(Classifier).allFeatures()->includes(operation)
// INV --- else target.type.oclAsType(Classifier).allFeatures()->includes(onPort) and onPort.provided->union(onPort.required).allFeatures()->includes(operation)
// INV --- endif

// --- --- --- class --- Clause */

// --- invariant body_output_pins 
// --- category IGN_COMPLEX
// OCL --- The bodyOutput Pins are OutputPins on Actions in the body of the Clause.
// INV --- _'body'.oclAsType(Action).allActions().output->includesAll(bodyOutput)
      

// --- invariant decider_output 
// --- category ATTR 
// OCL --- The decider Pin must be on an Action in the test section of the Clause and must be of type Boolean with multiplicity 1..1.
// INV --- test.oclAsType(Action).allActions().output->includes(decider) and
// INV --- decider.type = Boolean and
// INV --- decider.is(1,1)
      

// --- invariant test_and_body 
// --- category SIZE
// OCL --- The test and body parts of a ConditionalNode must be disjoint with each other.
// INV --- test->intersection(_'body')->isEmpty()
      
// --- --- --- class --- ClearAssociationAction */

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the  InputPin is 1..1.
// INV --- .is(1,1)
      

// --- invariant same_type 
// --- category INV_EXISTS 
// OCL --- The type of the InputPin must conform to the type of at least one of the memberEnds of the association.
// INV --- association.memberEnd->exists(self..type.conformsTo(type))
invariant same_type (uml.Property p)
context uml.ClearAssociationAction
check _self.association.memberEnds.exists[org.eclipse.uml2.uml.Property p|p.type.conformsTo(p.type)]
      
// --- --- --- class --- ClearStructuralFeatureAction */

// --- invariant type_of_result 
// --- category ATTR 
// OCL --- The type of the result OutputPin is the same as the type of the inherited  InputPin.
// INV --- result<>null implies result.type = .type
      

// --- invariant multiplicity_of_result 
// --- category ATTR 
// OCL --- The multiplicity of the result OutputPin must be 1..1.
// INV --- result<>null implies result.is(1,1)
      
// --- --- --- class --- ConditionalNode */

// --- invariant result_no_incoming 
// --- category SIZE
// OCL --- The result OutputPins have no incoming edges.
// INV --- result.incoming->isEmpty()
      

// --- invariant no_input_pins 
// --- category SIZE
// OCL --- A ConditionalNode has no InputPins.
// INV --- input->isEmpty()
      

// --- invariant one_clause_with_executable_node 
// --- category INV_FORALL
// OCL --- No ExecutableNode in the ConditionNode may appear in the test or body part of more than one clause of a ConditionalNode.
// INV --- node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)->forAll(n | 
// INV ---   self.clause->select(test->union(_'body')->includes(n))->size()=1)
invariant one_clause_with_executable_node (uml.ExecutableNode n)
context uml.ConditionalNode
check _self.nodes.filterType(org.eclipse.uml2.uml.ExecutableNode).forAll[org.eclipse.uml2.uml.ExecutableNode n|
	_self.clauses.select[c|c.tests.union(c.bodies).includes(n)].size == 1
]
      

// --- invariant matching_output_pins 
// --- category IGN_COMPLEX
// OCL --- Each clause of a ConditionalNode must have the same number of bodyOutput pins as the ConditionalNode has result OutputPins, and each clause bodyOutput Pin must be compatible with the corresponding result OutputPin (by positional order) in type, multiplicity, ordering, and uniqueness.
// INV --- clause->forAll(
// INV ---   bodyOutput->size()=self.result->size() and
// INV ---   Sequence{1..self.result->size()}->forAll(i |
// INV ---     bodyOutput->at(i).type.conformsTo(result->at(i).type) and
// INV ---     bodyOutput->at(i).isOrdered = result->at(i).isOrdered and
// INV ---     bodyOutput->at(i).isUnique = result->at(i).isUnique and
// INV ---     bodyOutput->at(i).compatibleWith(result->at(i))))
      

// --- invariant executable_nodes 
// --- category IGN_COMPLEX
// OCL --- The union of the ExecutableNodes in the test and body parts of all clauses must be the same as the subset of nodes contained in the ConditionalNode (considered as a StructuredActivityNode) that are ExecutableNodes.
// INV --- clause.test->union(clause._'body') = node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)
      

// --- invariant clause_no_predecessor 
// --- category IGN_COMPLEX
// OCL --- No two clauses within a ConditionalNode may be predecessorClauses of each other, either directly or indirectly.
// INV --- clause->closure(predecessorClause)->intersection(clause)->isEmpty()
      
// --- --- --- class --- CreateLinkAction */

// --- invariant association_not_abstract 
// --- category ATTR
// OCL --- The Association cannot be an abstract Classifier.
// INV --- not self.association().isAbstract
      
// --- --- --- class --- LinkEndCreationData */

// --- invariant insertAt_pin 
// --- category ATTR
// OCL --- LinkEndCreationData for ordered Association ends must have a single insertAt InputPin for the insertion point with type UnlimitedNatural and multiplicity of 1..1, if isReplaceAll=false, and must have no InputPin for the insertion point when the association ends are unordered.
// INV --- if  not end.isOrdered
// INV --- then insertAt = null
// INV --- else
// INV ---   not isReplaceAll=false implies
// INV ---   insertAt <> null and insertAt->forAll(type=UnlimitedNatural and is(1,1))
// INV --- endif
  
// --- --- --- class --- CreateLinkObjectAction */

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the OutputPin is 1..1.
// INV --- result.is(1,1)
      

// --- invariant type_of_result 
// --- category ATTR 
// OCL --- The type of the result OutputPin must be the same as the Association of the CreateLinkObjectAction.
// INV --- result.type = association()
      

// --- invariant association_class 
// --- category ATTR 
// OCL --- The Association must be an AssociationClass.
// INV --- self.association().oclIsKindOf(AssociationClass)
      
// --- --- --- class --- CreateObjectAction

// --- invariant classifier_not_abstract 
// --- category ATTR 
// OCL --- The classifier cannot be abstract.
// INV --- not classifier.isAbstract
      

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the result OutputPin is 1..1.
// INV --- result.is(1,1)
      

// --- invariant classifier_not_association_class 
// --- category ATTR 
// OCL --- The classifier cannot be an AssociationClass.
// INV --- not classifier.oclIsKindOf(AssociationClass)
      

// --- invariant same_type 
// --- category ATTR 
// OCL --- The type of the result OutputPin must be the same as the classifier of the CreateObjectAction.
// INV --- result.type = classifier
      
// --- --- --- class --- LinkEndDestructionData */

// --- invariant destroyAt_pin 
// --- category ATTR
// OCL --- LinkEndDestructionData for ordered, nonunique Association ends must have a single destroyAt InputPin if isDestroyDuplicates is false, which must be of type UnlimitedNatural and have a multiplicity of 1..1. Otherwise, the action has no destroyAt input pin.
// INV --- if  not end.isOrdered or end.isUnique or isDestroyDuplicates
// INV --- then destroyAt = null
// INV --- else
// INV ---   destroyAt <> null and 
// INV ---   destroyAt->forAll(type=UnlimitedNatural and is(1,1))
// INV --- endif
      
// --- --- --- class --- DestroyObjectAction */

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the targe IinputPin is 1..1.
// INV --- target.is(1,1)
      

// --- invariant no_type 
// --- category ATTR 
// OCL --- The target InputPin has no type.
// INV --- target.type= null
      
// --- --- --- class --- ExpansionNode */

// --- invariant region_as_input_or_output 
// --- category SIZE
// OCL --- One of regionAsInput or regionAsOutput must be non-empty, but not both.
// INV --- regionAsInput->notEmpty() xor regionAsOutput->notEmpty()
      
// --- --- --- class --- LoopNode */

// --- invariant result_no_incoming 
// --- category SIZE
// OCL --- The result OutputPins have no incoming edges.
// INV --- result.incoming->isEmpty()
      

// --- invariant input_edges 
// --- category SIZE
// OCL --- The loopVariableInputs must not have outgoing edges.
// INV --- loopVariableInput.outgoing->isEmpty()
      

// --- invariant executable_nodes 
// --- category IGN_COMPLEX
// OCL --- The union of the ExecutableNodes in the setupPart, test and bodyPart of a LoopNode must be the same as the subset of nodes contained in the LoopNode (considered as a StructuredActivityNode) that are ExecutableNodes.
// INV --- setupPart->union(test)->union(bodyPart)=node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)->asSet()
      

// --- invariant body_output_pins 
// --- category IGN_COMPLEX
// OCL --- The bodyOutput pins are OutputPins on Actions in the body of the LoopNode.
// INV --- bodyPart.oclAsType(Action).allActions().output->includesAll(bodyOutput)
      

// --- invariant setup_test_and_body 
// --- category SIZE
// OCL --- The test and body parts of a ConditionalNode must be disjoint with each other.
// INV --- setupPart->intersection(test)->isEmpty() and
// INV --- setupPart->intersection(bodyPart)->isEmpty() and
// INV --- test->intersection(bodyPart)->isEmpty()
      

// --- invariant matching_output_pins 
// --- category IGN_COMPLEX
// OCL --- A LoopNode must have the same number of bodyOutput Pins as loopVariables, and each bodyOutput Pin must be compatible with the corresponding loopVariable (by positional order) in type, multiplicity, ordering and uniqueness.
// INV --- bodyOutput->size()=loopVariable->size() and
// INV --- Sequence{1..loopVariable->size()}->forAll(i |
// INV ---   bodyOutput->at(i).type.conformsTo(loopVariable->at(i).type) and
// INV ---   bodyOutput->at(i).isOrdered = loopVariable->at(i).isOrdered and
// INV ---   bodyOutput->at(i).isUnique = loopVariable->at(i).isUnique and
// INV ---   loopVariable->at(i).includesMultiplicity(bodyOutput->at(i)))
      

// --- invariant matching_loop_variables 
// --- category SIZE
// OCL --- A LoopNode must have the same number of loopVariableInputs and loopVariables, and they must match in type, uniqueness and multiplicity.
// INV --- loopVariableInput->size()=loopVariable->size() and
// INV --- loopVariableInput.type=loopVariable.type and
// INV --- loopVariableInput.isUnique=loopVariable.isUnique and
// INV --- loopVariableInput.lower=loopVariable.lower and
// INV --- loopVariableInput.upper=loopVariable.upper
      

// --- invariant matching_result_pins 
// --- category SIZE
// OCL --- A LoopNode must have the same number of result OutputPins and loopVariables, and they must match in type, uniqueness and multiplicity.
// INV --- result->size()=loopVariable->size() and
// INV --- result.type=loopVariable.type and
// INV --- result.isUnique=loopVariable.isUnique and
// INV --- result.lower=loopVariable.lower and
// INV --- result.upper=loopVariable.upper
      

// --- invariant loop_variable_outgoing 
// --- category INV_FORALL* 
// OCL --- All ActivityEdges outgoing from loopVariable OutputPins must have targets within the LoopNode.
// INV --- allOwnedNodes()->includesAll(loopVariable.outgoing.target)
invariant loop_variable_outgoing (uml.ActivityEdge o)
context uml.LoopNode
check _self.loopVariables.map[l|l.outgoings].flatten
	.forAll[org.eclipse.uml2.uml.ActivityEdge o|_self.allOwnedNodes.includes(o.target)]
      
// --- --- --- class --- OpaqueAction */

// --- invariant language_body_size 
// --- category SIZE
// OCL --- If the language attribute is not empty, then the size of the body and language lists must be the same.
// INV --- language->notEmpty() implies (_'body'->size() = language->size())
      
// --- --- --- class --- ReadExtentAction */

// --- invariant type_is_classifier 
// --- category ATTR 
// OCL --- The type of the result OutputPin is the classifier.
// INV --- result.type = classifier
      

// --- invariant multiplicity_of_result 
// --- category ATTR 
// OCL --- The multiplicity of the result OutputPin is 0..*.
// INV --- result.is(0,*)
      
// --- --- --- class --- ReadIsClassifiedObjectAction */

// --- invariant no_type 
// --- category ATTR 
// OCL --- The  InputPin has no type.
// INV --- .type = null
      

// --- invariant multiplicity_of_output 
// --- category ATTR 
// OCL --- The multiplicity of the result OutputPin is 1..1.
// INV --- result.is(1,1)
      

// --- invariant boolean_result 
// --- category ATTR 
// OCL --- The type of the result OutputPin is Boolean.
// INV --- result.type = Boolean
      

// --- invariant multiplicity_of_input 
// --- category ATTR 
// OCL --- The multiplicity of the  InputPin is 1..1.
// INV --- .is(1,1)
      
// --- --- --- class --- ReadLinkAction */

// --- invariant type_and_ordering 
// --- category INV_FORALL 
// OCL --- The type and ordering of the result OutputPin are same as the type and ordering of the open Association end.
// INV --- self.openEnd()->forAll(type=result.type and isOrdered=result.isOrdered)
invariant type_and_ordering (uml.Property p)
context uml.ReadLinkAction
check _self.openEnd.forAll[org.eclipse.uml2.uml.Property p|p.type == _self.result.type && p.ordered == _self.result.ordered]
      

// --- invariant compatible_multiplicity 
// --- category INV_FORALL* 
// OCL --- The multiplicity of the open Association end must be compatible with the multiplicity of the result OutputPin.
// INV --- self.openEnd()->first().compatibleWith(result)
invariant type_and_ordering (uml.Property p)
context uml.ReadLinkAction
check _self.openEnd.forAll[org.eclipse.uml2.uml.Property p|p.compatibleWith(_self.result)]
      

// --- invariant visibility 
// --- category ATTR
// OCL --- Visibility of the open end must allow access from the  performing the action.
// INV --- let openEnd : Property = self.openEnd()->first() in
// INV ---   openEnd.visibility = VisibilityKind::public or 
// INV ---   endData->exists(oed | 
// INV ---     oed.end<>openEnd and 
// INV ---     (_'' = oed.end.type or 
// INV ---       (openEnd.visibility = VisibilityKind::protected and 
// INV ---         _''.conformsTo(oed.end.type.oclAsType(Classifier)))))
      

// --- invariant one_open_end 
// --- category SIZE
// OCL --- Exactly one linkEndData specification (corresponding to the &quot;open&quot; end) must not have an value InputPin.
// INV --- self.openEnd()->size() = 1
      

// --- invariant navigable_open_end 
// --- category INV_FORALL* 
// OCL --- The open end must be navigable.
// INV --- self.openEnd()->first().isNavigable()
invariant type_and_ordering (uml.Property p)
context uml.ReadLinkAction
check _self.openEnd.forAll[org.eclipse.uml2.uml.Property p|p.navigable]
      
// --- --- --- class --- ReadLinkObjectEndAction */

// --- invariant property 
// --- category ATTR 
// OCL --- The end Property must be an Association memberEnd.
// INV --- end.association <> null
      

// --- invariant multiplicity_of_object 
// --- category ATTR 
// OCL --- The multiplicity of the  InputPin is 1..1.
// INV --- .is(1,1)
      

// --- invariant ends_of_association 
// --- category INV_FORALL 
// OCL --- The ends of the association must not be static.
// INV --- end.association.memberEnd->forAll(e | not e.isStatic)
invariant ends_of_association (uml.Property e)
context uml.ReadLinkObjectEndAction
check _self.end.association.memberEnds.forAll[org.eclipse.uml2.uml.Property e|!e.isStatic]
      

// --- invariant type_of_result 
// --- category ATTR 
// OCL --- The type of the result OutputPin is the same as the type of the end Property.
// INV --- result.type = end.type
      

// --- invariant multiplicity_of_result 
// --- category ATTR 
// OCL --- The multiplicity of the result OutputPin is 1..1.
// INV --- result.is(1,1)
      

// --- invariant type_of_object 
// --- category ATTR 
// OCL --- The type of the  InputPin is the AssociationClass that owns the end Property.
// INV --- .type = end.association
      

// --- invariant association_of_association 
// --- category ATTR 
// OCL --- The association of the end must be an AssociationClass.
// INV --- end.association.oclIsKindOf(AssociationClass)
      
// --- --- --- class --- ReadLinkObjectEndQualifierAction */

// --- invariant multiplicity_of_object 
// --- category ATTR 
// OCL --- The multiplicity of the  InputPin is 1..1.
// INV --- .is(1,1)
      

// --- invariant type_of_object 
// --- category ATTR 
// OCL --- The type of the  InputPin is the AssociationClass that owns the Association end that has the given qualifier Property.
// INV --- .type = qualifier.associationEnd.association
      

// --- invariant multiplicity_of_qualifier 
// --- category ATTR 
// OCL --- The multiplicity of the qualifier Property is 1..1.
// INV --- qualifier.is(1,1)
      

// --- invariant ends_of_association 
// --- category INV_FORALL 
// OCL --- The ends of the Association must not be static.
// INV --- qualifier.associationEnd.association.memberEnd->forAll(e | not e.isStatic)
invariant ends_of_association (uml.Property p)
context uml.ReadLinkObjectEndQualifierAction
check _self.qualifier.associationEnd.association.memberEnds.forAll[org.eclipse.uml2.uml.Property p|!p.isStatic]
      

// --- invariant multiplicity_of_result 
// --- category ATTR 
// OCL --- The multiplicity of the result OutputPin is 1..1.
// INV --- result.is(1,1)
      

// --- invariant same_type 
// --- category ATTR 
// OCL --- The type of the result OutputPin is the same as the type of the qualifier Property.
// INV --- result.type = qualifier.type
      

// --- invariant association_of_association 
// --- category ATTR 
// OCL --- The association of the Association end of the qualifier Property must be an AssociationClass.
// INV --- qualifier.associationEnd.association.oclIsKindOf(AssociationClass)
      

// --- invariant qualifier_attribute 
// --- category ATTR 
// OCL --- The qualifier Property must be a qualifier of an Association end.
// INV --- qualifier.associationEnd <> null
      
// --- --- --- class --- ReadSelfAction */

// --- invariant contained 
// --- category ATTR 
// OCL --- A ReadSelfAction must have a  Classifier.
// INV --- _'' <> null
      

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the result OutputPin is 1..1.
// INV --- result.is(1,1)
      

// --- invariant not_static 
// --- category ATTR 
// OCL --- If the ReadSelfAction is contained in an Behavior that is acting as a method, then the Operation of the method must not be static.
// INV --- let behavior: Behavior = self.containingBehavior() in
// INV --- behavior.specification<>null implies not behavior.specification.isStatic
      

// --- invariant type 
// --- category ATTR 
// OCL --- The type of the result OutputPin is the  Classifier.
// INV --- result.type = _''

// --- --- --- class --- ReadStructuralFeatureAction */

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the StructuralFeature must be compatible with the multiplicity of the result OutputPin.
// INV --- structuralFeature.compatibleWith(result)
        

// --- invariant type_and_ordering 
// --- category ATTR 
// OCL --- The type and ordering of the result OutputPin are the same as the type and ordering of the StructuralFeature.
// INV --- result.type =structuralFeature.type and 
// INV --- result.isOrdered = structuralFeature.isOrdered
      
// --- --- --- class --- ReadVariableAction */

// --- invariant type_and_ordering 
// --- category ATTR 
// OCL --- The type and ordering of the result OutputPin are the same as the type and ordering of the variable.
// INV --- result.type =variable.type and 
// INV --- result.isOrdered = variable.isOrdered
      

// --- invariant compatible_multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the variable must be compatible with the multiplicity of the output pin.
// INV --- variable.compatibleWith(result)
      
// --- --- --- class --- ReclassifyObjectAction */

// --- invariant input_pin 
// --- category ATTR 
// OCL --- The  InputPin has no type.
// INV --- .type = null
      

// --- invariant classifier_not_abstract 
// --- category INV_EXISTS 
// OCL --- None of the newClassifiers may be abstract.
// INV --- not newClassifier->exists(isAbstract)
invariant classifier_not_abstract (uml.Classifier c)
context uml.ReclassifyObjectAction
check !_self.newClassifiers.exists[org.eclipse.uml2.uml.Classifier c|c.abstract]
      

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the  InputPin is 1..1.
// INV --- .is(1,1)
      
// --- --- --- class --- ReduceAction */

// --- invariant reducer_inputs_output 
// --- category SIZE
// OCL --- The reducer Behavior must have two input ownedParameters and one output ownedParameter, where the type of the output Parameter and the type of elements of the input collection conform to the types of the input Parameters.
// INV --- let inputs: OrderedSet(Parameter) = reducer.inputParameters() in
// INV --- let outputs: OrderedSet(Parameter) = reducer.outputParameters() in
// INV --- inputs->size()=2 and outputs->size()=1 and
// INV --- inputs.type->forAll(t | 
// INV ---   outputs.type->forAll(conformsTo(t)) and 
// INV ---   -- Note that the following only checks the case when the collection is via multiple tokens.
// INV ---   collection.upperBound()>1 implies collection.type.conformsTo(t))
      

// --- invariant input_type_is_collection 
// --- category IGN_TEXTUAL 
// OCL --- The type of the collection InputPin must be a collection.
      

// --- invariant output_types_are_compatible 
// --- category INV_MAP_FORALL 
// OCL --- The type of the output of the reducer Behavior must conform to the type of the result OutputPin.
// INV --- reducer.outputParameters().type->forAll(conformsTo(result.type))
invariant output_types_are_compatible (uml.Parameter p)
context uml.ReduceAction
check _self.reducer.outputParameters.map[org.eclipse.uml2.uml.Parameter p|p.type].forAll[t|t.conformsTo(_self.result.type)]
      
// --- --- --- class --- RemoveStructuralFeatureValueAction */

// --- invariant removeAt_and_value 
// --- category ATTR 
// OCL --- RemoveStructuralFeatureValueActions removing a value from ordered, non-unique StructuralFeatures must have a single removeAt InputPin and no value InputPin, if isRemoveDuplicates is false. The removeAt InputPin must be of type Unlimited Natural with multiplicity 1..1. Otherwise, the Action has a value InputPin and no removeAt InputPin.
// INV --- if structuralFeature.isOrdered and not structuralFeature.isUnique and  not isRemoveDuplicates then
// INV ---   value = null and
// INV ---   removeAt <> null and
// INV ---   removeAt.type = UnlimitedNatural and
// INV ---   removeAt.is(1,1)
// INV --- else
// INV ---   removeAt = null and value <> null
// INV --- endif
      
// --- --- --- class --- RemoveVariableValueAction */

// --- invariant removeAt_and_value 
// --- category ATTR 
// OCL --- ReadVariableActions removing a value from ordered, non-unique Variables must have a single removeAt InputPin and no value InputPin, if isRemoveDuplicates is false. The removeAt InputPin must be of type Unlimited Natural with multiplicity 1..1. Otherwise, the Action has a value InputPin and no removeAt InputPin.
// INV --- if  variable.isOrdered and not variable.isUnique and not isRemoveDuplicates then 
// INV ---   value = null and
// INV ---   removeAt <> null and
// INV ---   removeAt.type = UnlimitedNatural and
// INV ---   removeAt.is(1,1)
// INV --- else
// INV ---   removeAt = null and value <> null
// INV --- endif
      
// --- --- --- class --- ReplyAction */

// --- invariant pins_match_parameter 
// --- category IGN_COMPLEX
// OCL --- The replyValue InputPins must match the output (return, out, and inout) parameters of the operation of the event of the replyToCall Trigger in number, type, ordering, and multiplicity.
// INV --- let parameter:OrderedSet(Parameter) = replyToCall.event.oclAsType(CallEvent).operation.outputParameters() in
// INV --- replyValue->size()=parameter->size() and
// INV --- Sequence{1..replyValue->size()}->forAll(i |
// INV ---   replyValue->at(i).type.conformsTo(parameter->at(i).type) and
// INV ---   replyValue->at(i).isOrdered=parameter->at(i).isOrdered and
// INV ---   replyValue->at(i).compatibleWith(parameter->at(i)))
      

// --- invariant event_on_reply_to_call_trigger 
// --- category ATTR 
// OCL --- The event of the replyToCall Trigger must be a CallEvent.
// INV --- replyToCall.event.oclIsKindOf(CallEvent)
      
// --- --- --- class --- SendObjectAction */

// --- invariant type_target_pin 
// --- category IGN_COMPLEX
// OCL --- If onPort is not empty, the Port given by onPort must be an owned or inherited feature of the type of the target InputPin.
// INV --- onPort<>null implies target.type.oclAsType(Classifier).allFeatures()->includes(onPort)
      
// --- --- --- class --- SendSignalAction */

// --- invariant type_ordering_multiplicity 
// --- category IGN_COMPLEX
// OCL --- The type, ordering, and multiplicity of an argument InputPin must be the same as the corresponding attribute of the signal.
// INV --- let attribute: OrderedSet(Property) = signal.allAttributes() in
// INV --- Sequence{1..argument->size()}->forAll(i | 
// INV ---   argument->at(i).type.conformsTo(attribute->at(i).type) and 
// INV ---   argument->at(i).isOrdered = attribute->at(i).isOrdered and
// INV ---   argument->at(i).compatibleWith(attribute->at(i)))
      

// --- invariant number_order 
// --- category SIZE
// OCL --- The number and order of argument InputPins must be the same as the number and order of attributes of the signal.
// INV --- argument->size()=signal.allAttributes()->size()
  

// --- invariant type_target_pin 
// --- category IGN_COMPLEX
// OCL --- If onPort is not empty, the Port given by onPort must be an owned or inherited feature of the type of the target InputPin.
// INV --- not onPort->isEmpty() implies target.type.oclAsType(Classifier).allFeatures()->includes(onPort)
      
// --- --- --- class --- StartClassifierBehaviorAction */

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the  InputPin is 1..1
// INV --- .is(1,1)
      

// --- invariant type_has_classifier 
// --- category ATTR 
// OCL --- If the InputPin has a type, then the type or one of its ancestors must have a classifierBehavior.
// INV --- .type->notEmpty() implies 
// INV ---    (.type.oclIsKindOf(BehavioredClassifier) and .type.oclAsType(BehavioredClassifier).classifierBehavior<>null)
      
// --- --- --- class --- StartObjectBehaviorAction */

// --- invariant multiplicity_of_object 
// --- category ATTR 
// OCL --- The multiplicity of the  InputPin must be 1..1.
// INV --- .is(1,1)
     

// --- invariant type_of_object 
// --- category ATTR 
// OCL --- The type of the  InputPin must be either a Behavior or a BehavioredClassifier with a classifierBehavior.
// INV --- self.behavior()<>null
      

// --- invariant no_onport 
// --- category SIZE
// OCL --- A StartObjectBehaviorAction may not specify onPort.
// INV --- onPort->isEmpty()
      
// --- --- --- class --- TestIdentityAction */

// --- invariant multiplicity 
// --- category ATTR 
// OCL --- The multiplicity of the InputPins is 1..1.
// INV --- first.is(1,1) and second.is(1,1)
   

// --- invariant no_type 
// --- category ATTR 
// OCL --- The InputPins have no type.
// INV --- first.type= null and second.type = null
      

// --- invariant result_is_boolean 
// --- category ATTR 
// OCL --- The type of the result OutputPin is Boolean.
// INV --- result.type=Boolean
      
// --- --- --- class --- UnmarshallAction */

// --- invariant structural_feature 
// --- category SIZE
// OCL --- The unmarshallType must have at least one StructuralFeature.
// INV --- unmarshallType.allAttributes()->size() >= 1

// --- --- --- class --- ValuePin */

// --- invariant no_incoming_edges 
// --- category SIZE
// OCL --- A ValuePin may have no incoming ActivityEdges.
// INV --- incoming->isEmpty()
      

// --- invariant compatible_type 
// --- category ATTR 
// OCL --- The type of the value ValueSpecification must conform to the type of the ValuePin.
// INV --- value.type.conformsTo(type)
      
// --- --- --- class --- FinalNode */

// --- invariant no_outgoing_edges 
// --- category SIZE_EMPTY
// OCL --- A FinalNode has no outgoing ActivityEdges.
// INV --- outgoing->isEmpty()

// --- --- --- class --- ActivityParameterNode */

// --- invariant no_outgoing_edges 
// --- category ATTR 
// OCL --- An ActivityParameterNode with no outgoing ActivityEdges and one or more incoming ActivityEdges must have a parameter with direction out, inout, or return.
// INV --- (incoming->notEmpty() and outgoing->isEmpty()) implies 
// INV ---   (parameter.direction = ParameterDirectionKind::out or 
// INV ---    parameter.direction = ParameterDirectionKind::inout or 
// INV ---    parameter.direction = ParameterDirectionKind::return)
      

// --- invariant has_parameters 
// --- category INV_EXISTS* 
// OCL --- The parameter of an ActivityParameterNode must be from the containing Activity.
// INV --- activity.ownedParameter->includes(parameter)
invariant has_parameters (uml.Parameter p)
context uml.ActivityParameterNode
check _self.activity.ownedParameters.exists[org.eclipse.uml2.uml.Parameter p| p == _self.parameter]
      

// --- invariant same_type 
// --- category ATTR 
// OCL --- The type of an ActivityParameterNode is the same as the type of its parameter.
// INV --- type = parameter.type
      

// --- invariant no_incoming_edges 
// --- category ATTR 
// OCL --- An ActivityParameterNode with no incoming ActivityEdges and one or more outgoing ActivityEdges must have a parameter with direction in or inout.
// INV --- (outgoing->notEmpty() and incoming->isEmpty()) implies 
// INV ---   (parameter.direction = ParameterDirectionKind::_'in' or 
// INV ---    parameter.direction = ParameterDirectionKind::inout)
      

// --- invariant no_edges 
// --- category SIZE
// OCL --- An ActivityParameterNode may have all incoming ActivityEdges or all outgoing ActivityEdges, but it must not have both incoming and outgoing ActivityEdges.
// INV --- incoming->isEmpty() or outgoing->isEmpty()
      
// --- --- --- class --- ControlFlow */

// --- invariant object_nodes 
// --- category ATTR 
// OCL --- ControlFlows may not have ObjectNodes at either end, except for ObjectNodes with control type.
// INV --- (source.oclIsKindOf(ObjectNode) implies source.oclAsType(ObjectNode).isControlType) and 
// INV --- (target.oclIsKindOf(ObjectNode) implies target.oclAsType(ObjectNode).isControlType)
      
// --- --- --- class --- DecisionNode */

// --- invariant zero_input_parameters 
// --- category SIZE
// OCL --- If the DecisionNode has no decisionInputFlow and an incoming ControlFlow, then any decisionInput Behavior has no in parameters.
// INV --- (decisionInput<>null and decisionInputFlow=null and incoming->exists(oclIsKindOf(ControlFlow))) implies
// INV ---    decisionInput.inputParameters()->isEmpty()
      

// --- invariant edges 
// --- category IGN_COMPLEX
// OCL --- The ActivityEdges incoming to and outgoing from a DecisionNode, other than the decisionInputFlow (if any), must be either all ObjectFlows or all ControlFlows.
// INV --- let allEdges: Set(ActivityEdge) = incoming->union(outgoing) in
// INV --- let allRelevantEdges: Set(ActivityEdge) = if decisionInputFlow->notEmpty() then allEdges->excluding(decisionInputFlow) else allEdges endif in
// INV --- allRelevantEdges->forAll(oclIsKindOf(ControlFlow)) or allRelevantEdges->forAll(oclIsKindOf(ObjectFlow))
// INV --- 
      

// --- invariant decision_input_flow_incoming 
// --- category INV_EXISTS* 
// OCL --- The decisionInputFlow of a DecisionNode must be an incoming ActivityEdge of the DecisionNode.
// INV --- incoming->includes(decisionInputFlow)
invariant decision_input_flow_incoming (uml.ActivityEdge e)
context uml.DecisionNode
check _self.incomings.exists[org.eclipse.uml2.uml.ActivityEdge e|e == _self.decisionInputFlow]
      

// --- invariant two_input_parameters 
// --- category SIZE
// OCL --- If the DecisionNode has a decisionInputFlow and an second incoming ObjectFlow, then any decisionInput has two in Parameters, the first of which has a type that is the same as or a supertype of the type of  tokens offered on the non-decisionInputFlow and the second of which has a type that is the same as or a supertype of the type of  tokens offered on the decisionInputFlow.
// INV --- (decisionInput<>null and decisionInputFlow<>null and incoming->forAll(oclIsKindOf(ObjectFlow))) implies
// INV ---   decisionInput.inputParameters()->size()=2
      

// --- invariant incoming_outgoing_edges 
// --- category SIZE
// OCL --- A DecisionNode has one or two incoming ActivityEdges and at least one outgoing ActivityEdge.
// INV --- (incoming->size() = 1 or incoming->size() = 2) and outgoing->size() > 0
      

// --- invariant incoming_control_one_input_parameter
// --- category SIZE
// OCL --- If the DecisionNode has a decisionInputFlow and an incoming ControlFlow, then any decisionInput Behavior has one in Parameter whose type is the same as or a supertype of the type of  tokens offered on the decisionInputFlow.
// INV --- (decisionInput<>null and decisionInputFlow<>null and incoming->exists(oclIsKindOf(ControlFlow))) implies
// INV ---   decisionInput.inputParameters()->size()=1
      

// --- invariant parameters 
// --- category INV_FORALL 
// OCL --- A decisionInput Behavior has no out parameters, no inout parameters, and one return parameter.
// INV --- decisionInput<>null implies 
// INV ---   (decisionInput.ownedParameter->forAll(par | 
// INV ---      par.direction <> ParameterDirectionKind::out and 
// INV ---      par.direction <> ParameterDirectionKind::inout ) and
// INV ---    decisionInput.ownedParameter->one(par | 
// INV ---      par.direction <> ParameterDirectionKind::return))
invariant parameters (uml.Parameter par)
context uml.DecisionNode
check _self.decisionInput == null || 
	_self.decisionInput.ownedParameters.forAll[org.eclipse.uml2.uml.Parameter par|
		par.direction != org.eclipse.uml2.uml.ParameterDirectionKind.OUT &&
		par.direction != org.eclipse.uml2.uml.ParameterDirectionKind.INOUT
	] &&
	_self.decisionInput.ownedParameters.select[p|p.direction == org.eclipse.uml2.uml.ParameterDirectionKind.RETURN].size == 1
      

// --- invariant incoming_object_one_input_parameter
// --- category SIZE
// OCL --- If the DecisionNode has no decisionInputFlow and an incoming ObjectFlow, then any decisionInput Behavior has one in Parameter whose type is the same as or a supertype of the type of  tokens offered on the incoming ObjectFlow.
// INV --- (decisionInput<>null and decisionInputFlow=null and incoming->forAll(oclIsKindOf(ObjectFlow))) implies
// INV ---   decisionInput.inputParameters()->size()=1
      
// --- --- --- class --- ObjectFlow */

// --- invariant input_and_output_parameter
// --- category SIZE
// OCL --- A selection Behavior has one input Parameter and one output Parameter. The input Parameter must have the same as or a supertype of the type of the source ObjectNode, be non-unique and have multiplicity 0..*. The output Parameter must be the same or a subtype of the type of source ObjectNode. The Behavior cannot have side effects.
// INV --- selection<>null implies
// INV ---   selection.inputParameters()->size()=1 and
// INV ---   selection.inputParameters()->forAll(not isUnique and is(0,*)) and
// INV ---   selection.outputParameters()->size()=1
      

// --- invariant no_executable_nodes 
// --- category ATTR 
// OCL --- ObjectFlows may not have ExecutableNodes at either end.
// INV --- not (source.oclIsKindOf(ExecutableNode) or target.oclIsKindOf(ExecutableNode))
      

// --- invariant transformation_behavior
// --- category SIZE
// OCL --- A transformation Behavior has one input Parameter and one output Parameter. The input Parameter must be the same as or a supertype of the type of  token coming from the source end. The output Parameter must be the same or a subtype of the type of  token expected downstream. The Behavior cannot have side effects.
// INV --- transformation<>null implies
// INV ---   transformation.inputParameters()->size()=1 and
// INV ---   transformation.outputParameters()->size()=1
      

// --- invariant selection_behavior 
// --- category ATTR 
// OCL --- An ObjectFlow may have a selection Behavior only if it has an ObjectNode as its source.
// INV --- selection<>null implies source.oclIsKindOf(ObjectNode)
      

// --- invariant compatible_types 
// --- category IGN_TEXTUAL 
// OCL --- ObjectNodes connected by an ObjectFlow, with optionally intervening ControlNodes, must have compatible types. In particular, the downstream ObjectNode type must be the same or a supertype of the upstream ObjectNode type.
      

// --- invariant same_upper_bounds 
// --- category IGN_TEXTUAL 
// OCL --- ObjectNodes connected by an ObjectFlow, with optionally intervening ControlNodes, must have the same upperBounds.
      

// --- invariant target 
// --- category IGN_TEXTUAL 
// OCL --- An ObjectFlow with a constant weight may not target an ObjectNode, with optionally intervening ControlNodes, that has an upper bound less than the weight.
      

// --- invariant is_multicast_or_is_multireceive 
// --- category ATTR 
// OCL --- isMulticast and isMultireceive cannot both be true.
// INV --- not (isMulticast and isMultireceive)
      
// --- --- --- class --- ForkNode */

// --- invariant edges 
// --- category INV_FORALL 
// OCL --- The ActivityEdges incoming to and outgoing from a ForkNode must be either all ObjectFlows or all ControlFlows.
// INV --- let allEdges : Set(ActivityEdge) = incoming->union(outgoing) in
// INV --- allEdges->forAll(oclIsKindOf(ControlFlow)) or allEdges->forAll(oclIsKindOf(ObjectFlow))
invariant edges (uml.ActivityEdge c, uml.ActivityEdge o)
context uml.ForkNode
check _self.incomings.union(_self.outgoings).forAll[org.eclipse.uml2.uml.ActivityEdge c|c.oclIsKindOf(org.eclipse.uml2.uml.ControlFlow)] ||
	_self.incomings.union(_self.outgoings).forAll[org.eclipse.uml2.uml.ActivityEdge o|o.oclIsKindOf(org.eclipse.uml2.uml.ObjectFlow)]
      

// --- invariant one_incoming_edge 
// --- category SIZE
// OCL --- A ForkNode has one incoming ActivityEdge.
// INV --- incoming->size()=1
      
// --- --- --- class --- InitialNode */

// --- invariant no_incoming_edges 
// --- category SIZE
// OCL --- An InitialNode has no incoming ActivityEdges.
// INV --- incoming->isEmpty()
      

// --- invariant control_edges 
// --- category INV_FORALL 
// OCL --- All the outgoing ActivityEdges from an InitialNode must be ControlFlows.
// INV --- outgoing->forAll(oclIsKindOf(ControlFlow))
invariant control_edges (uml.ActivityEdge e)
context uml.InitialNode
check _self.outgoings.forAll[org.eclipse.uml2.uml.ActivityEdge e|e.oclIsKindOf(org.eclipse.uml2.uml.ControlFlow)]
      
// --- --- --- class --- JoinNode */

// --- invariant one_outgoing_edge 
// --- category SIZE
// OCL --- A JoinNode has one outgoing ActivityEdge.
// INV --- outgoing->size() = 1
      

// --- invariant incoming_object_flow 
// --- category IGN_COMPLEX
// OCL --- If one of the incoming ActivityEdges of a JoinNode is an ObjectFlow, then its outgoing ActivityEdge must be an ObjectFlow. Otherwise its outgoing ActivityEdge must be a ControlFlow.
// INV --- if incoming->exists(oclIsKindOf(ObjectFlow)) then outgoing->forAll(oclIsKindOf(ObjectFlow))
// INV --- else outgoing->forAll(oclIsKindOf(ControlFlow))
// INV --- endif
      
// --- --- --- class --- MergeNode */

// --- invariant one_outgoing_edge 
// --- category SIZE
// OCL --- A MergeNode has one outgoing ActivityEdge.
// INV --- outgoing->size()=1
      

// --- invariant edges 
// --- category INV_FORALL 
// OCL --- The ActivityEdges incoming to and outgoing from a MergeNode must be either all ObjectFlows or all ControlFlows.
// INV --- let allEdges : Set(ActivityEdge) = incoming->union(outgoing) in
// INV --- allEdges->forAll(oclIsKindOf(ControlFlow)) or allEdges->forAll(oclIsKindOf(ObjectFlow))
invariant edges (uml.ActivityEdge c, uml.ActivityEdge o)
context uml.MergeNode
check _self.incomings.union(_self.outgoings).forAll[org.eclipse.uml2.uml.ActivityEdge c|c.oclIsKindOf(org.eclipse.uml2.uml.ControlFlow)] ||
	_self.incomings.union(_self.outgoings).forAll[org.eclipse.uml2.uml.ActivityEdge o|o.oclIsKindOf(org.eclipse.uml2.uml.ObjectFlow)]
      
// --- --- --- class --- FunctionBehavior */

// --- invariant one_output_parameter 
// --- category INV_EXISTS* 
// OCL --- A FunctionBehavior has at least one output Parameter.
// INV --- self.ownedParameter->
// INV ---   select(p | p.direction = ParameterDirectionKind::out or p.direction= ParameterDirectionKind::inout or p.direction= ParameterDirectionKind::return)->size() >= 1
invariant one_output_parameter (uml.Parameter p)
context uml.FunctionBehavior
check _self.ownedParameters.exists[org.eclipse.uml2.uml.Parameter p|
	p.direction == org.eclipse.uml2.uml.ParameterDirectionKind.OUT ||
	p.direction == org.eclipse.uml2.uml.ParameterDirectionKind.INOUT ||
	p.direction == org.eclipse.uml2.uml.ParameterDirectionKind.RETURN
]
      

// --- invariant types_of_parameters 
// --- category INV_FORALL
// OCL --- The types of the ownedParameters are all DataTypes, which may not nest anything but other DataTypes.
// INV --- ownedParameter->forAll(p | p.type <> null and
// INV ---   p.type.oclIsTypeOf(DataType) and hasAllDataTypeAttributes(p.type.oclAsType(DataType)))
invariant types_of_parameters (uml.Parameter p)
context uml.FunctionBehavior
check _self.ownedParameters.forAll[org.eclipse.uml2.uml.Parameter p|
	p.type != null && p.type.oclIsKindOf(org.eclipse.uml2.uml.DataType)
		&& _self.hasAllDataTypeAttributes(p.type.oclAsType(org.eclipse.uml2.uml.DataType))
]
      
// --- --- --- class --- TimeEvent */

// --- invariant when_non_negative 
// --- category ATTR 
// OCL --- The ValueSpecification when must return a non-negative Integer.
// INV --- when.integerValue() >= 0
      
// --- --- --- class --- TimeExpression */

// --- invariant no_expr_requires_observation 
// --- category INV_FORALL 
// OCL --- If a TimeExpression has no expr, then it must have a single observation that is a TimeObservation.
// INV --- expr = null implies (observation->size() = 1 and observation->forAll(oclIsKindOf(TimeObservation)))
invariant no_expr_requires_observation (uml.Observation o)
context uml.TimeExpression
check _self.expr != null || _self.observations.size == 1 && _self.observations.forAll[org.eclipse.uml2.uml.Observation o|o.oclIsKindOf(org.eclipse.uml2.uml.TimeObservation)]
      
// --- --- --- class --- CommunicationPath */

// --- invariant association_ends 
// --- category INV_FORALL 
// OCL --- The association ends of a CommunicationPath are typed by DeploymentTargets.
// INV --- endType->forAll (oclIsKindOf(DeploymentTarget))
invariant association_ends_2 (uml.Type t)
context uml.CommunicationPath
check _self.endTypes.forAll[org.eclipse.uml2.uml.Type t|t.oclIsKindOf(org.eclipse.uml2.uml.DeploymentTarget)]
  
// --- --- --- class --- Node */

// --- invariant internal_structure 
// --- category INV_FORALL
// OCL --- The internal structure of a Node (if defined) consists solely of parts of type Node.
// INV --- part->forAll(oclIsKindOf(Node))
invariant association_ends_2 (uml.Property t)
context uml.Node
check _self.parts.forAll[org.eclipse.uml2.uml.Property t|t.oclIsKindOf(org.eclipse.uml2.uml.Node)]
      
// --- --- --- class --- InformationFlow */

// --- invariant must_conform 
// --- category IGN_TEXTUAL 
// OCL --- The sources and targets of the information flow must conform to the sources and targets or conversely the targets and sources of the realization relationships.
      

// --- invariant sources_and_targets_kind 
// --- category IGN_COMPLEX
// OCL --- The sources and targets of the information flow can only be one of the following kind: Actor, Node, UseCase, Artifact, Class, Component, Port, Property, Interface, Package, ActivityNode, ActivityPartition,
// INV --- Behavior and InstanceSpecification except when its classifier is a relationship (i.e. it represents a link).
// INV --- (self.informationSource->forAll( sis |
// INV ---   oclIsKindOf(Actor) or oclIsKindOf(Node) or oclIsKindOf(UseCase) or oclIsKindOf(Artifact) or 
// INV ---   oclIsKindOf(Class) or oclIsKindOf(Component) or oclIsKindOf(Port) or oclIsKindOf(Property) or 
// INV ---   oclIsKindOf(Interface) or oclIsKindOf(Package) or oclIsKindOf(ActivityNode) or oclIsKindOf(ActivityPartition) or 
// INV ---   (oclIsKindOf(InstanceSpecification) and not sis.oclAsType(InstanceSpecification).classifier->exists(oclIsKindOf(Relationship))))) 
// INV --- 
// INV --- and
// INV --- 
// INV --- (self.informationTarget->forAll( sit | 
// INV ---   oclIsKindOf(Actor) or oclIsKindOf(Node) or oclIsKindOf(UseCase) or oclIsKindOf(Artifact) or 
// INV ---   oclIsKindOf(Class) or oclIsKindOf(Component) or oclIsKindOf(Port) or oclIsKindOf(Property) or 
// INV ---   oclIsKindOf(Interface) or oclIsKindOf(Package) or oclIsKindOf(ActivityNode) or oclIsKindOf(ActivityPartition) or 
// INV --- (oclIsKindOf(InstanceSpecification) and not sit.oclAsType(InstanceSpecification).classifier->exists(oclIsKindOf(Relationship)))))
      

// --- invariant convey_classifiers 
// --- category INV_FORALL 
// OCL --- An information flow can only convey classifiers that are allowed to represent an information item.
// INV --- self.conveyed->forAll(oclIsKindOf(Class) or oclIsKindOf(Interface)
// INV ---   or oclIsKindOf(InformationItem) or oclIsKindOf(Signal) or oclIsKindOf(Component))
invariant convey_classifiers (uml.Classifier t)
context uml.InformationFlow
check _self.conveyeds.forAll[org.eclipse.uml2.uml.Classifier t|
	t.oclIsKindOf(org.eclipse.uml2.uml.Class) ||
	t.oclIsKindOf(org.eclipse.uml2.uml.Interface) ||
	t.oclIsKindOf(org.eclipse.uml2.uml.InformationItem) ||
	t.oclIsKindOf(org.eclipse.uml2.uml.Signal) ||
	t.oclIsKindOf(org.eclipse.uml2.uml.Component)
]
      
// --- --- --- class --- Message */

// --- invariant sending_receiving_message_event 
// --- category IGN_COMPLEX
// OCL --- If the sendEvent and the receiveEvent of the same Message are on the same Lifeline, the sendEvent must be ordered before the receiveEvent.
// INV --- receiveEvent.oclIsKindOf(MessageOccurrenceSpecification)
// INV --- implies
// INV --- let f :  Lifeline = sendEvent->select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first().covered in
// INV --- f = receiveEvent->select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first().covered  implies
// INV --- f.events->indexOf(sendEvent.oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first() ) < 
// INV --- f.events->indexOf(receiveEvent.oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first() )
      

// --- invariant arguments 
// --- category IGN_TEXTUAL 
// OCL --- Arguments of a Message must only be: i) attributes of the sending lifeline, ii) constants, iii) symbolic values (which are wildcard values representing any legal value), iv) explicit parameters of the enclosing Interaction, v) attributes of the class owning the Interaction.
      

// --- invariant cannot_cross_boundaries 
// --- category IGN_COMPLEX
// OCL --- Messages cannot cross boundaries of CombinedFragments or their operands.  This is true if and only if both MessageEnds are enclosed within the same InteractionFragment (i.e., an InteractionOperand or an Interaction).
// INV --- sendEvent->notEmpty() and receiveEvent->notEmpty() implies
// INV --- let sendEnclosingFrag : Set(InteractionFragment) = 
// INV --- sendEvent->asOrderedSet()->first().enclosingFragment()
// INV --- in 
// INV --- let receiveEnclosingFrag : Set(InteractionFragment) = 
// INV --- receiveEvent->asOrderedSet()->first().enclosingFragment()
// INV --- in  sendEnclosingFrag = receiveEnclosingFrag
      

// --- invariant signature_is_signal 
// --- category IGN_COMPLEX
// OCL --- In the case when the Message signature is a Signal, the arguments of the Message must correspond to the attributes of the Signal. A Message Argument corresponds to a Signal Attribute if the Argument is of the same Class or a specialization of that of the Attribute.
// INV --- (messageSort = MessageSort::asynchSignal ) and signature.oclIsKindOf(Signal) implies
// INV ---    let signalAttributes : OrderedSet(Property) = signature.oclAsType(Signal).inheritedMember()->
// INV ---              select(n:NamedElement | n.oclIsTypeOf(Property))->collect(oclAsType(Property))->asOrderedSet()
// INV ---    in signalAttributes->size() = self.argument->size()
// INV ---    and self.argument->forAll( o: ValueSpecification |
// INV ---           not (o.oclIsKindOf(Expression)
// INV ---           and o.oclAsType(Expression).symbol->size()=0
// INV ---           and o.oclAsType(Expression).operand->isEmpty() ) implies
// INV ---               let p : Property = signalAttributes->at(self.argument->indexOf(o))
// INV ---               in o.type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier)))
      

// --- invariant occurrence_specifications 
// --- category IGN_TEXTUAL 
// OCL --- If the MessageEnds are both OccurrenceSpecifications, then the connector must go between the Parts represented by the Lifelines of the two MessageEnds.
      

// --- invariant signature_refer_to 
// --- category ATTR 
// OCL --- The signature must either refer an Operation (in which case messageSort is either synchCall or asynchCall or reply) or a Signal (in which case messageSort is asynchSignal). The name of the NamedElement referenced by signature must be the same as that of the Message.
// INV --- signature->notEmpty() implies 
// INV --- ((signature.oclIsKindOf(Operation) and 
// INV --- (messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall or messageSort = MessageSort::reply) 
// INV --- ) or (signature.oclIsKindOf(Signal)  and messageSort = MessageSort::asynchSignal )
// INV ---  ) and name = signature.name
      

// --- invariant signature_is_operation_request 
// --- category IGN_COMPLEX
// OCL --- In the case when a Message with messageSort synchCall or asynchCall has a non empty Operation signature, the arguments of the Message must correspond to the in and inout parameters of the Operation. A Parameter corresponds to an Argument if the Argument is of the same Class or a specialization of that of the Parameter.
// INV --- (messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall) and signature.oclIsKindOf(Operation)  implies 
// INV ---  let requestParms : OrderedSet(Parameter) = signature.oclAsType(Operation).ownedParameter->
// INV ---  select(direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::_'in'  )
// INV --- in requestParms->size() = self.argument->size() and
// INV --- self.argument->forAll( o: ValueSpecification | 
// INV --- not (o.oclIsKindOf(Expression) and o.oclAsType(Expression).symbol->size()=0 and o.oclAsType(Expression).operand->isEmpty() ) implies 
// INV --- let p : Parameter = requestParms->at(self.argument->indexOf(o)) in
// INV --- o.type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier))
// INV --- )
      

// --- invariant signature_is_operation_reply 
// --- category IGN_COMPLEX
// OCL --- In the case when a Message with messageSort reply has a non empty Operation signature, the arguments of the Message must correspond to the out, inout, and return parameters of the Operation. A Parameter corresponds to an Argument if the Argument is of the same Class or a specialization of that of the Parameter.
// INV --- (messageSort = MessageSort::reply) and signature.oclIsKindOf(Operation) implies 
// INV ---  let replyParms : OrderedSet(Parameter) = signature.oclAsType(Operation).ownedParameter->
// INV --- select(direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::out or direction = ParameterDirectionKind::return)
// INV --- in replyParms->size() = self.argument->size() and
// INV --- self.argument->forAll( o: ValueSpecification | o.oclIsKindOf(Expression) and let e : Expression = o.oclAsType(Expression) in
// INV --- e.operand->notEmpty()  implies 
// INV --- let p : Parameter = replyParms->at(self.argument->indexOf(o)) in
// INV --- e.operand->asSequence()->first().type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier))
// INV --- )
      
// --- --- --- class --- Interaction */

// --- invariant not_contained 
// --- category ATTR 
// OCL --- An Interaction instance must not be contained within another Interaction instance.
// INV --- enclosingInteraction->isEmpty()
      
// --- --- --- class --- Lifeline

// --- invariant selector_specified 
// --- category ATTR 
// OCL --- The selector for a Lifeline must only be specified if the referenced Part is multivalued.
// INV ---  self.selector->notEmpty() = (self.represents.oclIsKindOf(MultiplicityElement) and self.represents.oclAsType(MultiplicityElement).isMultivalued())
      

// --- invariant interaction_uses_share_lifeline 
// --- category IGN_COMPLEX
// OCL --- If a lifeline is in an Interaction referred to by an InteractionUse in an enclosing Interaction,  and that lifeline is common with another lifeline in an Interaction referred to by another InteractonUse within that same enclosing Interaction, it must be common to a lifeline within that enclosing Interaction. By common Lifelines we mean Lifelines with the same selector and represents associations.
// INV --- let intUses : Set(InteractionUse) = interaction.interactionUse  in 
// INV --- intUses->forAll
// INV --- ( iuse : InteractionUse | 
// INV --- let usingInteraction : Set(Interaction)  = iuse.enclosingInteraction->asSet()
// INV --- ->union(
// INV --- iuse.enclosingOperand.combinedFragment->asSet()->closure(enclosingOperand.combinedFragment).enclosingInteraction->asSet()
// INV ---                ) 
// INV --- in
// INV --- let peerUses : Set(InteractionUse) = usingInteraction.fragment->select(oclIsKindOf(InteractionUse)).oclAsType(InteractionUse)->asSet()
// INV --- ->union(
// INV --- usingInteraction.fragment->select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)->asSet()
// INV --- ->closure(operand.fragment->select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)).operand.fragment->
// INV --- select(oclIsKindOf(InteractionUse)).oclAsType(InteractionUse)->asSet()
// INV ---                )->excluding(iuse)
// INV ---  in
// INV --- peerUses->forAll( peerUse : InteractionUse |
// INV ---  peerUse.refersTo.lifeline->forAll( l : Lifeline | (l.represents = self.represents and 
// INV ---  ( self.selector.oclIsKindOf(LiteralString) implies
// INV ---   l.selector.oclIsKindOf(LiteralString) and 
// INV ---   self.selector.oclAsType(LiteralString).value = l.selector.oclAsType(LiteralString).value )
// INV ---   and 
// INV --- ( self.selector.oclIsKindOf(LiteralInteger) implies
// INV ---   l.selector.oclIsKindOf(LiteralInteger) and 
// INV ---   self.selector.oclAsType(LiteralInteger).value = l.selector.oclAsType(LiteralInteger).value )
// INV --- )  
// INV --- implies
// INV ---  usingInteraction.lifeline->exists(represents = self.represents and
// INV ---  ( self.selector.oclIsKindOf(LiteralString) implies
// INV ---   l.selector.oclIsKindOf(LiteralString) and 
// INV ---   self.selector.oclAsType(LiteralString).value = l.selector.oclAsType(LiteralString).value )
// INV --- and 
// INV --- ( self.selector.oclIsKindOf(LiteralInteger) implies
// INV ---   l.selector.oclIsKindOf(LiteralInteger) and 
// INV ---   self.selector.oclAsType(LiteralInteger).value = l.selector.oclAsType(LiteralInteger).value )
// INV --- )
// INV ---                                                 )
// INV ---                     )
// INV --- )
      

// --- invariant same_classifier 
// --- category IGN_COMPLEX
// OCL --- The classifier containing the referenced ConnectableElement must be the same classifier, or an ancestor, of the classifier that contains the interaction enclosing this lifeline.
// INV --- represents.namespace->closure(namespace)->includes(interaction._'')
      

// --- invariant selector_int_or_string 
// --- category ATTR 
// OCL --- The selector value, if present, must be a LiteralString or a LiteralInteger
// INV --- self.selector->notEmpty() implies 
// INV --- self.selector.oclIsKindOf(LiteralInteger) or 
// INV --- self.selector.oclIsKindOf(LiteralString)
      
// --- --- --- class --- PartDecomposition */

// --- invariant commutativity_of_decomposition 
// --- category IGN_TEXTUAL 
// OCL --- Assume that within Interaction X, Lifeline L is of class C and decomposed to D. Assume also that there is within X an InteractionUse (say) U that covers L. According to the constraint above U will have a counterpart CU within D. Within the Interaction referenced by U, L should also be decomposed, and the decomposition should reference CU. (This rule is called commutativity of decomposition.)
      

// --- invariant assume 
// --- category IGN_TEXTUAL 
// OCL --- Assume that within Interaction X, Lifeline L is of class C and decomposed to D. Within X there is a sequence of constructs along L (such constructs are CombinedFragments, InteractionUse and (plain) OccurrenceSpecifications). Then a corresponding sequence of constructs must appear within D, matched one-to-one in the same order. i) CombinedFragment covering L are matched with an extra-global CombinedFragment in D. ii) An InteractionUse covering L is matched with a global (i.e., covering all Lifelines) InteractionUse in D. iii) A plain OccurrenceSpecification on L is considered an actualGate that must be matched by a formalGate of D.
      

// --- invariant parts_of_internal_structures 
// --- category IGN_TEXTUAL 
// OCL --- PartDecompositions apply only to Parts that are Parts of Internal Structures not to Parts of Collaborations.
      
// --- --- --- class --- InteractionUse */

// --- invariant gates_match 
// --- category SIZE
// OCL --- Actual Gates of the InteractionUse must match Formal Gates of the referred Interaction. Gates match when their names are equal and their messages correspond.
// INV --- actualGate->notEmpty() implies 
// INV --- refersTo.formalGate->forAll( fg : Gate | self.actualGate->select(matches(fg))->size()=1) and
// INV --- self.actualGate->forAll(ag : Gate | refersTo.formalGate->select(matches(ag))->size()=1)
      

// --- invariant arguments_are_constants 
// --- category IGN_TEXTUAL 
// OCL --- The arguments must only be constants, parameters of the enclosing Interaction or attributes of the classifier owning the enclosing Interaction.
      

// --- invariant returnValueRecipient_coverage 
// --- category IGN_COMPLEX
// OCL --- The returnValueRecipient must be a Property of a ConnectableElement that is represented by a Lifeline covered by this InteractionUse.
// INV --- returnValueRecipient->asSet()->notEmpty() implies
// INV --- let covCE : Set(ConnectableElement) = covered.represents->asSet() in 
// INV --- covCE->notEmpty() and let classes:Set(Classifier) = covCE.type.oclIsKindOf(Classifier).oclAsType(Classifier)->asSet() in 
// INV --- let allProps : Set(Property) = classes.attribute->union(classes.allParents().attribute)->asSet() in 
// INV --- allProps->includes(returnValueRecipient)
      

// --- invariant arguments_correspond_to_parameters 
// --- category IGN_TEXTUAL 
// OCL --- The arguments of the InteractionUse must correspond to parameters of the referred Interaction.
      

// --- invariant returnValue_type_recipient_correspondence 
// --- category ATTR 
// OCL --- The type of the returnValue must correspond to the type of the returnValueRecipient.
// INV --- returnValue.type->asSequence()->notEmpty() implies returnValue.type->asSequence()->first() = returnValueRecipient.type->asSequence()->first()
      

// --- invariant all_lifelines 
// --- category IGN_COMPLEX
// OCL --- The InteractionUse must cover all Lifelines of the enclosing Interaction that are common with the lifelines covered by the referred Interaction. Lifelines are common if they have the same selector and represents associationEnd values.
// INV --- let parentInteraction : Set(Interaction) = enclosingInteraction->asSet()->
// INV --- union(enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)->
// INV --- collect(enclosingInteraction).oclAsType(Interaction)->asSet()) in
// INV --- parentInteraction->size()=1 and let refInteraction : Interaction = refersTo in
// INV --- parentInteraction.covered-> forAll(intLifeline : Lifeline | refInteraction.covered->
// INV --- forAll( refLifeline : Lifeline | refLifeline.represents = intLifeline.represents and 
// INV --- (
// INV --- ( refLifeline.selector.oclIsKindOf(LiteralString) implies
// INV ---   intLifeline.selector.oclIsKindOf(LiteralString) and 
// INV ---   refLifeline.selector.oclAsType(LiteralString).value = intLifeline.selector.oclAsType(LiteralString).value ) and
// INV --- ( refLifeline.selector.oclIsKindOf(LiteralInteger) implies
// INV ---   intLifeline.selector.oclIsKindOf(LiteralInteger) and 
// INV ---   refLifeline.selector.oclAsType(LiteralInteger).value = intLifeline.selector.oclAsType(LiteralInteger).value )
// INV --- )
// INV ---  implies self.covered->asSet()->includes(intLifeline)))
      
// --- --- --- class --- Gate */

// --- invariant actual_gate_matched 
// --- category SIZE
// OCL --- If this Gate is an actualGate, it must have exactly one matching formalGate within the referred Interaction.
// INV --- interactionUse->notEmpty() implies interactionUse.refersTo.formalGate->select(matches(self))->size()=1
      

// --- invariant inside_cf_matched 
// --- category SIZE
// OCL --- If this Gate is inside a CombinedFragment, it must have exactly one matching Gate which is outside of that CombinedFragment.
// INV --- isInsideCF() implies combinedFragment.cfragmentGate->select(isOutsideCF() and matches(self))->size()=1
      

// --- invariant outside_cf_matched 
// --- category IGN_COMPLEX
// OCL --- If this Gate is outside an 'alt' CombinedFragment,  for every InteractionOperator inside that CombinedFragment there must be exactly one matching Gate inside the CombindedFragment with its opposing end enclosed by that InteractionOperator. If this Gate is outside CombinedFragment with operator other than 'alt',   there must be exactly one matching Gate inside that CombinedFragment.
// INV --- isOutsideCF() implies
// INV ---  if self.combinedFragment.interactionOperator->asOrderedSet()->first() = InteractionOperatorKind::alt
// INV ---  then self.combinedFragment.operand->forAll(op : InteractionOperand |
// INV ---  self.combinedFragment.cfragmentGate->select(isInsideCF() and 
// INV ---  oppositeEnd().enclosingFragment()->includes(self.combinedFragment) and matches(self))->size()=1)
// INV ---  else  self.combinedFragment.cfragmentGate->select(isInsideCF() and matches(self))->size()=1
// INV ---  endif
      

// --- invariant formal_gate_distinguishable 
// --- category SIZE
// OCL --- isFormal() implies that no other formalGate of the parent Interaction returns the same getName() as returned for self
// INV --- isFormal() implies interaction.formalGate->select(getName() = self.getName())->size()=1
      

// --- invariant actual_gate_distinguishable 
// --- category SIZE
// OCL --- isActual() implies that no other actualGate of the parent InteractionUse returns the same getName() as returned for self
// INV --- isActual() implies interactionUse.actualGate->select(getName() = self.getName())->size()=1
      

// --- invariant outside_cf_gate_distinguishable 
// --- category SIZE
// OCL --- isOutsideCF() implies that no other outside cfragmentGate of the parent CombinedFragment returns the same getName() as returned for self
// INV --- isOutsideCF() implies combinedFragment.cfragmentGate->select(getName() = self.getName())->size()=1
      

// --- invariant inside_cf_gate_distinguishable 
// --- category SIZE
// OCL --- isInsideCF() implies that no other inside cfragmentGate attached to a message with its other end in the same InteractionOperator as self, returns the same getName() as returned for self
// INV --- isInsideCF() implies
// INV --- let selfOperand : InteractionOperand = self.getOperand() in
// INV ---   combinedFragment.cfragmentGate->select(isInsideCF() and getName() = self.getName())->select(getOperand() = selfOperand)->size()=1
      
// --- --- --- class --- InteractionOperand */

// --- invariant guard_contain_references 
// --- category IGN_TEXTUAL 
// OCL --- The guard must contain only references to values local to the Lifeline on which it resides, or values global to the whole Interaction.
      

// --- invariant guard_directly_prior 
// --- category IGN_TEXTUAL 
// OCL --- The guard must be placed directly prior to (above) the OccurrenceSpecification that will become the first OccurrenceSpecification within this InteractionOperand.
      
// --- --- --- class --- InteractionConstraint */

// --- invariant minint_maxint 
// --- category ATTR
// OCL --- Minint/maxint can only be present if the InteractionConstraint is associated with the operand of a loop CombinedFragment.
// INV --- maxint->notEmpty() or minint->notEmpty() implies
// INV --- interactionOperand.combinedFragment.interactionOperator =
// INV --- InteractionOperatorKind::loop
      

// --- invariant minint_non_negative 
// --- category ATTR 
// OCL --- If minint is specified, then the expression must evaluate to a non-negative integer.
// INV --- minint->notEmpty() implies 
// INV --- minint->asSequence()->first().integerValue() >= 0
      

// --- invariant maxint_positive 
// --- category ATTR 
// OCL --- If maxint is specified, then the expression must evaluate to a positive integer.
// INV --- maxint->notEmpty() implies 
// INV --- maxint->asSequence()->first().integerValue() > 0
      

// --- invariant dynamic_variables 
// --- category IGN_TEXTUAL 
// OCL --- The dynamic variables that take part in the constraint must be owned by the ConnectableElement corresponding to the covered Lifeline.
      

// --- invariant global_data 
// --- category IGN_TEXTUAL 
// OCL --- The constraint may contain references to global data or write-once data.
      

// --- invariant maxint_greater_equal_minint 
// --- category ATTR 
// OCL --- If maxint is specified, then minint must be specified and the evaluation of maxint must be >= the evaluation of minint.
// INV --- maxint->notEmpty() implies (minint->notEmpty() and 
// INV --- maxint->asSequence()->first().integerValue() >=
// INV --- minint->asSequence()->first().integerValue() )
      
// --- --- --- class --- GeneralOrdering */

// --- invariant irreflexive_transitive_closure 
// --- category IGN_COMPLEX
// OCL --- An occurrence specification must not be ordered relative to itself through a series of general orderings. (In other words, the transitive closure of the general orderings is irreflexive.)
// INV --- after->closure(toAfter.after)->excludes(before)
      
// --- --- --- class --- InformationItem */

// --- invariant sources_and_targets 
// --- category IGN_ILLEGAL
// OCL --- The sources and targets of an information item (its related information flows) must designate subsets of the sources and targets of the representation information item, if any. The Classifiers that can realize an information item can only be of the following kind: Class, Interface, InformationItem, Signal, Component.
// INV --- (self.represented->select(oclIsKindOf(InformationItem))->forAll(p |
// INV ---   p.conveyingFlow.source->forAll(q | self.conveyingFlow.source->includes(q)) and
// INV ---     p.conveyingFlow.target->forAll(q | self.conveyingFlow.target->includes(q)))) and
// INV ---       (self.represented->forAll(oclIsKindOf(Class) or oclIsKindOf(Interface) or
// INV ---         oclIsKindOf(InformationItem) or oclIsKindOf(Signal) or oclIsKindOf(Component)))
      

// --- invariant has_no 
// --- category SIZE
// OCL --- An informationItem has no feature, no generalization, and no associations.
// INV --- self.generalization->isEmpty() and self.feature->isEmpty()
      

// --- invariant not_instantiable 
// --- category ATTR 
// OCL --- It is not instantiable.
// INV --- isAbstract
      
// --- --- --- class --- ActionExecutionSpecification */

// --- invariant action_referenced 
// --- category IGN_COMPLEX
// OCL --- The Action referenced by the ActionExecutionSpecification must be owned by the Interaction owning that ActionExecutionSpecification.
// INV --- (enclosingInteraction->notEmpty() or enclosingOperand.combinedFragment->notEmpty()) and
// INV --- let parentInteraction : Set(Interaction) = enclosingInteraction.oclAsType(Interaction)->asSet()->union(
// INV --- enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)->
// INV --- collect(enclosingInteraction).oclAsType(Interaction)->asSet()) in
// INV --- (parentInteraction->size() = 1) and self.action.interaction->asSet() = parentInteraction

// --- --- --- class --- ExecutionSpecification */

// --- invariant same_lifeline 
// --- category ATTR 
// OCL --- The startEvent and the finishEvent must be on the same Lifeline.
// INV --- start.covered = finish.covered
      
// --- --- --- class --- CombinedFragment */

// --- invariant break 
// --- category IGN_COMPLEX
// OCL --- If the interactionOperator is break, the corresponding InteractionOperand must cover all Lifelines covered by the enclosing InteractionFragment.
// INV --- interactionOperator=InteractionOperatorKind::break  implies   
// INV --- enclosingInteraction.oclAsType(InteractionFragment)->asSet()->union(
// INV ---    enclosingOperand.oclAsType(InteractionFragment)->asSet()).covered->asSet() = self.covered->asSet()
      

// --- invariant consider_and_ignore 
// --- category ATTR 
// OCL --- The interaction operators 'consider' and 'ignore' can only be used for the ConsiderIgnoreFragment subtype of CombinedFragment
// INV --- ((interactionOperator = InteractionOperatorKind::consider) or (interactionOperator =  InteractionOperatorKind::ignore)) implies oclIsKindOf(ConsiderIgnoreFragment)
      

// --- invariant opt_loop_break_neg 
// --- category SIZE
// OCL --- If the interactionOperator is opt, loop, break, assert or neg, there must be exactly one operand.
// INV --- (interactionOperator =  InteractionOperatorKind::opt or interactionOperator = InteractionOperatorKind::loop or
// INV --- interactionOperator = InteractionOperatorKind::break or interactionOperator = InteractionOperatorKind::assert or
// INV --- interactionOperator = InteractionOperatorKind::neg)
// INV --- implies operand->size()=1
      
// --- --- --- class --- ConsiderIgnoreFragment */

// --- invariant consider_or_ignore 
// --- category ATTR 
// OCL --- The interaction operator of a ConsiderIgnoreFragment must be either 'consider' or 'ignore'.
// INV --- (interactionOperator =  InteractionOperatorKind::consider) or (interactionOperator =  InteractionOperatorKind::ignore)
      

// --- invariant type 
// --- category INV_FORALL 
// OCL --- The NamedElements must be of a type of element that can be a signature for a message (i.e.., an Operation, or a Signal).
// INV --- message->forAll(m | m.oclIsKindOf(Operation) or m.oclIsKindOf(Signal))
invariant type (uml.NamedElement e)
context uml.ConsiderIgnoreFragment
check _self.messages.forAll[org.eclipse.uml2.uml.NamedElement e| e.oclIsKindOf(org.eclipse.uml2.uml.Operation) || e.oclIsKindOf(org.eclipse.uml2.uml.Signal)]

// --- --- --- class --- Continuation */

// --- invariant first_or_last_interaction_fragment 
// --- category IGN_COMPLEX
// OCL --- Continuations always occur as the very first InteractionFragment or the very last InteractionFragment of the enclosing InteractionOperand.
// INV ---  enclosingOperand->notEmpty() and 
// INV ---  let peerFragments : OrderedSet(InteractionFragment) =  enclosingOperand.fragment in 
// INV ---    ( peerFragments->notEmpty() and 
// INV ---    ((peerFragments->first() = self) or  (peerFragments->last() = self)))
      

// --- invariant same_name 
// --- category IGN_COMPLEX
// OCL --- Across all Interaction instances having the same  value, every Lifeline instance covered by a Continuation (self) must be common with one covered Lifeline instance of all other Continuation instances with the same name as self, and every Lifeline instance covered by a Continuation instance with the same name as self must be common with one covered Lifeline instance of self. Lifeline instances are common if they have the same selector and represents associationEnd values.
// INV --- enclosingOperand.combinedFragment->notEmpty() and
// INV --- let parentInteraction : Set(Interaction) = 
// INV --- enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)->
// INV --- collect(enclosingInteraction).oclAsType(Interaction)->asSet()
// INV --- in 
// INV --- (parentInteraction->size() = 1) 
// INV --- and let peerInteractions : Set(Interaction) =
// INV ---  (parentInteraction->union(parentInteraction->collect(_'')->collect(behavior)->
// INV ---  select(oclIsKindOf(Interaction)).oclAsType(Interaction)->asSet())->asSet()) in
// INV ---  (peerInteractions->notEmpty()) and 
// INV ---   let combinedFragments1 : Set(CombinedFragment) = peerInteractions.fragment->
// INV ---  select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)->asSet() in
// INV ---    combinedFragments1->notEmpty() and  combinedFragments1->closure(operand.fragment->
// INV ---    select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment))->asSet().operand.fragment->
// INV ---    select(oclIsKindOf(Continuation)).oclAsType(Continuation)->asSet()->
// INV ---    forAll(c : Continuation |  (c.name = self.name) implies 
// INV ---   (c.covered->asSet()->forAll(cl : Lifeline | --  cl must be common to one lifeline covered by self
// INV ---   self.covered->asSet()->
// INV ---   select(represents = cl.represents and selector = cl.selector)->asSet()->size()=1))
// INV ---    and
// INV ---  (self.covered->asSet()->forAll(cl : Lifeline | --  cl must be common to one lifeline covered by c
// INV ---  c.covered->asSet()->
// INV ---   select(represents = cl.represents and selector = cl.selector)->asSet()->size()=1))
// INV ---   )
      

// --- invariant global 
// --- category INV_FORALL 
// OCL --- Continuations are always global in the enclosing InteractionFragment e.g., it always covers all Lifelines covered by the enclosing InteractionOperator.
// INV --- enclosingOperand->notEmpty() and
// INV ---   let operandLifelines : Set(Lifeline) =  enclosingOperand.covered in 
// INV ---     (operandLifelines->notEmpty() and 
// INV ---     operandLifelines->forAll(ol :Lifeline |self.covered->includes(ol)))
invariant global (uml.Lifeline ol)
context uml.Continuation
check _self.enclosingOperand.covereds.notEmpty && _self.enclosingOperand.covereds.forAll[org.eclipse.uml2.uml.Lifeline ol|_self.covereds.includes(ol)]
      
// --- --- --- class --- DestructionOccurrenceSpecification */

// --- invariant no_occurrence_specifications_below 
// --- category IGN_COMPLEX
// OCL --- No other OccurrenceSpecifications on a given Lifeline in an InteractionOperand may appear below a DestructionOccurrenceSpecification.
// INV --- let o : InteractionOperand = enclosingOperand in o->notEmpty() and 
// INV --- let peerEvents : OrderedSet(OccurrenceSpecification) = covered.events->select(enclosingOperand = o)
// INV --- in peerEvents->last() = self
      
// --- --- --- class --- FinalState */

// --- invariant no_exit_behavior 
// --- category SIZE
// OCL --- A FinalState has no exit Behavior.
// INV --- exit->isEmpty()
      

// --- invariant no_outgoing_transitions 
// --- category SIZE
// OCL --- A FinalState cannot have any outgoing Transitions.
// INV --- outgoing->size() = 0
      

// --- invariant no_regions 
// --- category SIZE
// OCL --- A FinalState cannot have Regions.
// INV --- region->size() = 0
      

// --- invariant cannot_reference_submachine 
// --- category SIZE
// OCL --- A FinalState cannot reference a submachine.
// INV --- submachine->isEmpty()
      

// --- invariant no_entry_behavior 
// --- category SIZE
// OCL --- A FinalState has no entry Behavior.
// INV --- entry->isEmpty()
      

// --- invariant no_state_behavior 
// --- category SIZE
// OCL --- A FinalState has no state (doActivity) Behavior.
// INV --- doActivity->isEmpty()

// --- --- --- class --- ProtocolTransition */

// --- invariant refers_to_operation 
// --- category IGN_COMPLEX
// OCL --- If a ProtocolTransition refers to an Operation (i.e., has a CallEvent trigger corresponding to an Operation), then that Operation should apply to the  Classifier of the StateMachine of the ProtocolTransition.
// INV --- if (referred()->notEmpty() and containingStateMachine()._''->notEmpty()) then 
// INV ---     containingStateMachine()._''.oclAsType(BehavioredClassifier).allFeatures()->includesAll(referred())
// INV --- else true endif
      

// --- invariant associated_actions 
// --- category ATTR 
// OCL --- A ProtocolTransition never has associated Behaviors.
// INV --- effect = null
      

// --- invariant belongs_to_psm 
// --- category ATTR 
// OCL --- A ProtocolTransition always belongs to a ProtocolStateMachine.
// INV --- container.belongsToPSM()
      
// --- --- --- class --- AssociationClass */

// --- invariant cannot_be_defined 
// --- category INV_EXISTS*
// OCL --- An AssociationClass cannot be defined between itself and something else.
// INV --- self.endType()->excludes(self) and self.endType()->collect(et|et.oclAsType(Classifier).allParents())->flatten()->excludes(self)
invariant cannot_be_defined (uml.Type et, uml.Classifier et2)
context uml.AssociationClass
check !_self.endTypes.exists[org.eclipse.uml2.uml.Type et|et == _self] 
	&& !_self.endTypes.map[e|e.oclAsType(org.eclipse.uml2.uml.Classifier).allParents].flatten
		.exists[org.eclipse.uml2.uml.Classifier et2|et2 == _self]
	 

// --- invariant disjoint_attributes_ends 
// --- category SIZE
// OCL --- The owned attributes and owned ends of an AssociationClass are disjoint.
// INV --- ownedAttribute->intersection(ownedEnd)->isEmpty()
      
// --- --- --- class --- Component */

// --- invariant no_nested_classifiers 
// --- category SIZE
// OCL --- A Component cannot nest Classifiers.
// INV --- nestedClassifier->isEmpty()
      

// --- invariant no_packaged_elements 
// --- category SIZE
// OCL --- A Component nested in a Class cannot have any packaged elements.
// INV --- nestingClass <> null implies packagedElement->isEmpty()
      
// --- --- --- class --- Actor */

// --- invariant associations 
// --- category IGN_COMPLEX
// OCL --- An Actor can only have Associations to UseCases, Components, and Classes. Furthermore these Associations must be binary.
// INV --- Association.allInstances()->forAll( a |
// INV ---   a.memberEnd->collect(type)->includes(self) implies
// INV ---   (
// INV ---     a.memberEnd->size() = 2 and
// INV ---     let actorEnd : Property = a.memberEnd->any(type = self) in
// INV ---       actorEnd.opposite.class.oclIsKindOf(UseCase) or
// INV ---       ( actorEnd.opposite.class.oclIsKindOf(Class) and not
// INV ---          actorEnd.opposite.class.oclIsKindOf(Behavior))
// INV ---       )
// INV ---   )
      

// --- invariant must_have_name 
// --- category ATTR 
// OCL --- An Actor must have a name.
// INV --- name->notEmpty()
      
// --- --- --- class --- Duration */

// --- invariant no_expr_requires_observation 
// --- category IGN_COMPLEX
// OCL --- If a Duration has no expr, then it must have a single observation that is a DurationObservation.
// INV --- expr = null implies (observation->size() = 1 and observation->forAll(oclIsKindOf(DurationObservation)))
      
// --- --- --- class --- DurationConstraint */

// --- invariant first_event_multiplicity 
// --- category SIZE
// OCL --- The multiplicity of firstEvent must be 2 if the multiplicity of constrainedElement is 2. Otherwise the multiplicity of firstEvent is 0.
// INV --- if (constrainedElement->size() = 2)
// INV ---   then (firstEvent->size() = 2) else (firstEvent->size() = 0) 
// INV --- endif
      

// --- invariant has_one_or_two_constrainedElements 
// --- category SIZE
// OCL --- A DurationConstraint has either one or two constrainedElements.
// INV --- constrainedElement->size() = 1 or constrainedElement->size()=2
      
// --- --- --- class --- DurationObservation */

// --- invariant first_event_multiplicity 
// --- category SIZE
// OCL --- The multiplicity of firstEvent must be 2 if the multiplicity of event is 2. Otherwise the multiplicity of firstEvent is 0.
// INV --- if (event->size() = 2)
// INV ---   then (firstEvent->size() = 2) else (firstEvent->size() = 0)
// INV --- endif
      
// --- --- --- class --- TimeConstraint */

// --- invariant has_one_constrainedElement 
// --- category SIZE
// OCL --- A TimeConstraint has one constrainedElement.
// INV --- constrainedElement->size() = 1
         